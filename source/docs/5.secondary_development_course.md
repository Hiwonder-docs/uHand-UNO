# 二次开发玩法课程

## 5.1 超声波库文件介绍（Ultrasound）

**Ultrasound**是控制发光超声波模块发送、读取信息、设置模块上RGB灯的颜色以及获取测量距离的库函数。在后续的声波测距、声波抓球玩法中需要调用该函数来实现检测距离及控制模块灯颜色变化的功能。

下面就其中几个使用频率较高的函数来进行说明。

### 1.成员函数（Ultrasound::Color）

```c
    //设置超声波rgb灯的颜色
    //r1，g1，b1表示右边rgb灯的三原色的比例，范围0-255
    //r2，g2，b2表示左边rgb灯的三原色的比例，范围0-255
    void Ultrasound::Color(uint8_t r1, uint8_t g1, uint8_t b1, uint8_t r2, uint8_t g2, uint8_t b2)
        {
          uint8_t RGB[6]; 
          uint8_t value = RGB_WORK_SIMPLE_MODE;
          
          wireWriteDataArray(ULTRASOUND_I2C_ADDR, RGB_WORK_MODE,&value,1);
          RGB[0] = r1;RGB[1] = g1;RGB[2] = b1;//RGB1
          RGB[3] = r2;RGB[4] = g2;RGB[5] = b2;//RGB2
          wireWriteDataArray(ULTRASOUND_I2C_ADDR, RGB1_R,RGB,6);
        }
```

这是一个**Ultrasound**类的其中一个成员函数，主要是用于控制发光超声波模块上RGB灯的颜色。它接收六个参数，分别是r1、g1、b1和r2、b2、g2，分别代表发光超声波模块上左右两个RGB灯的红绿蓝三色。该函数的相关描述可参考下表：

<table class="docutils-nobg" border="1" style="text-align:center;">
    <tbody>
        <tr style="height:40px">
            <th colspan="4">Ultrasound::Color()</th>
        </tr>
        <tr>
            <td>函数描述</td>
            <td colspan="3">控制发光超声波的RGB灯颜色</td>
        </tr>
        <tr>
            <td>参数列表</td>
            <td>r1、g1、b1、r2、g2、b2</td>
            <td>返回值</td>
            <td>无</td>
        </tr>
        <tr>
            <td rowspan="2">使用说明</td>
            <td colspan="3">
                1. Ultrasound u1; (创建发光超声波对象)  </td>
        </tr>
        <tr>
            <td colspan="3">2. ul.Color(0,0,255,0,0,255)</td>
        </tr>
    </tbody>
</table>

<p></p>

在函数中使用**wireWriteDataArray**来向发光超声波传感器的I2C地址写入数据。它向地址**ULTRASOUND_I2C_ADDR**写入一个字节的数据，该数据是**RGB_WORK_SIMPLE_MODE**的值。

然后将前面传入的两种颜色（RGB1和RGB2）的值分别赋给RGB数组的前六个元素。最后再次使用**wireWriteDataArray**函数，将前面设置的两种颜色的RGB值通过I2C协议发送给超声波传感器。

### 2.成员函数（Ultrasound::GetDistance）

这是一个**Ultrasound**类的其中一个成员函数，用于从发光超声波模块获取距离数据。

代码使用**wireReadDataArray**的函数从超声波传感器的I2C地址读取数据。从地址**ULTRASOUND_I2C_ADDR**的偏移量0处开始，读取2个字节的数据，并将这些数据存储在**distance**变量中，即获取到超声波模块的距离数据。

```c
    //获取超声波测得的距离单位mm
    u16 Ultrasound::GetDistance()
        {
          u16 distance;
          wireReadDataArray(ULTRASOUND_I2C_ADDR, 0,(uint8_t *)&distance,2);
          return distance;
        }
```



<table class="docutils" border="1" style="text-align:center">
	<tr style="height:40px">
        <th colspan="4"><strong>Ultrasound::GetDistance()</strong></th>
    </tr>
    <tr>
        <td>函数描述</td>
        <td colspan="3">直接获取发光超声波模块的测量距离</td>
    </tr>
    <tr>
        <td>参数列表</td>
        <td>无</td>
        <td>返回值</td>
        <td>返回u16类型的距离测量值</td>
    </tr>
    <tr>
        <td rowspan="2">使用说明</td>
        <td colspan="3">1. Ultrasound ul;（创建发光超声波对象）</td>
    </tr>
    <tr>
    	<td colspan="3">2. ul.GetDistance();(返回直接测量的的距离值，有干扰)</td>
    </tr>
</table>

<p></p>

### 3.成员函数（Ultrasound::Filter）

Filter一个**Ultrasound**类的其中一个成员函数，用于在**GetDistance**函数获取的数据之后对其进行滤波，减少干扰，获得一个更加平滑的平均值。

首先程序定义了滤波器的大小为3，用于存储最近读取的三个超声波测值。声明了一个静态整数数组filter_buf，其大小为FILTER_N + 1（即4）。

从**GetDistance**读取一个新的测值，并将其存储在filter_buf数组的最后一个位置。当数据累积到一定数量时，将filter_buf数组中的所有数据左移一位（丢弃最低位的数据），并将所有数据累加到**filter_sum**变量中，便于计算所有存储数据的总和。

最后，函数返回计算得到的平均值。这个平均值是通过将累加的总和除以滤波器的长度来计算的，结果被强制转换为整数类型并返回。

```c
    #define FILTER_N 3                //递推平均滤波法
    static int filter_buf[FILTER_N + 1];

    int Ultrasound::Filter(void) {
        int i;
        int filter_sum = 0;
        filter_buf[FILTER_N] = GetDistance();     //读取超声波测值
        for(i = 0; i < FILTER_N; i++) {
            filter_buf[i] = filter_buf[i + 1];               // 所有数据左移，低位仍掉
            filter_sum += filter_buf[i];
        }
    }
```

<table class="docutils" border="1" style="text-align:center">
	<tr style="height:40px">
    	<th colspan="4">Ultrasound::Filter()</th>
    </tr>
    <tr>
    	<td>函数描述</td>
        <td colspan="3">获取滤波后的测量值</td>
    </tr>
    <tr>
    	<td>参数列表</td>
        <td>无</td>
        <td>返回值</td>
        <td>返回int类型的滤波后的距离测量值</td>
    </tr>
    <tr>
    	<td rowspan="2">使用说明</td>
        <td colspan="3">1. Ultrasound ul;(创建发光超声波对象)</td>
    </tr>
    <tr>
        <td colspan="3">2. ul.Filter();(滤波后的数值，去除干扰)</td>
    </tr>
</table>

<p></p>

## 5.2 声波测距

本节通过发光超声波模块检测障碍物距离，实现手掌开合，同时控制RGB灯颜色变化。

### 1.实现流程图

<p align="center">
<img src="../_static/media/uhand uno-5/5-1.png" alt="5-1" style="width:700px"/>
</p>

### 2.超声波传感器

<p align="center">
<img src="../_static/media/uhand uno-5/5-2.png" alt="5-2" style="width:350px"/>
</p>

本节课用的是可发光的超声波测距模块，模块采用 IIC 通信接口，能通过 IIC通信进行读取超声波传感器测量的距离。

- #### 传感器工作原理

传感器测距时模块会自动发送 8 个 40khz 的方波，然后检测是否有信号返回； 如果有信号返回，便输出一个高电平，高电平持续的时间就是超声波从发射到返回的时间。

具体公式为：测试距离=(高电平时间\*声速(340M/S))/2。

- #### 传感器原理图

传感器通过CS100芯片控制，其中芯片引脚为（TP，TN）可发出8个40Khz方波，然后通过芯片引脚（RP，RN）检测回波信号，通过公式计算出距离值。

<p align="center">
<img src="../_static/media/uhand uno-5/5-3.png" alt="5-3" style="width:700px"/>
</p>

- **供电电压：5V**
- **工作电流：2mA**
- **有效测距：2cm - 400cm**

- #### 传感器接线

将超声波模块通过4Pin线接入任意IIC接口。

<p align="center">
<img src="../_static/media/uhand uno-5/5-4.png" alt="5-4" style="width:700px"/>
</p>

### 3.程序下载


:::{Note}

下载程序前需先将蓝牙模块取下，否则会因串口冲突导致程序下载失败。

接入Type-B下载线时请将电池盒开关拨到“OFF”挡，避免下载线误碰到扩展板的电源引脚，造成短路。

:::

1. 找到并打开本节同目录下的“ **02 程序文件\uhand_ultrasonic_ranging\uhand_ultrasonic_ranging.ino** ”程序文件。

<p align="center">
<img src="../_static/media/uhand uno-5/5-5.png" alt="5-5" style="width:700px"/>
</p>

将Arduino通过UNO数据线（Type-B）连接至电脑。

<p align="center">
<img src="../_static/media/uhand uno-5/5-6.png" alt="5-6" style="width:700px"/>
</p>

点击“**选择开发板**”选项，软件会自动检测当前Arduino串口，点击进行连接。

<p align="center">
<img src="../_static/media/uhand uno-5/5-7.png" alt="5-7" style="width:700px"/>
</p>

点击<img src="../_static/media/uhand uno-5/5-8.png" alt="5-8" style="width: 30px; margin: 0 5px;"/>，将程序下载至Arduino中，等待下载完成即可。

<p align="center">
	<img src="../_static/media/uhand uno-5/5-9.png" alt="5-9" style="width:700px"/>
</p>

<p align="center">
	<img src="../_static/media/uhand uno-5/5-10.png" alt="5-10" style="width:700px"/>
</p>

### 4.实现效果

打开机械手掌电源后，首先机械手掌会回到中位姿态，同时发光超声波模块和扩展板上RGB灯会亮蓝色。

<p align="center">
	<img src="../_static/media/uhand uno-5/5-11.png" alt="5-11" style="width:500px"/>
</p>


将障碍物正对超声波模块并移动障碍物使其缓慢靠近。

1. 当**距离>20cm时**，机械手掌五指张开，超声波模块和扩展板上RGB灯为蓝色；
2. 当**10cm>距离>20cm**时，障碍物靠近手掌，手掌将缓慢闭合，同时超声波模块和扩展板上的RGB灯由蓝色逐渐变为紫色；
3. 当**距离<10cm**时，手掌闭合握拳，同时超声波模块和扩展板上RGB灯亮红色。
<p align="center">
	<img src="../_static/media/uhand uno-5/5-12.png" alt="5-12" style="width:500px"/>
</p>
<p style="text-align:center;"><strong>（距离>20cm）</strong></p>
<p align="center">
	<img src="../_static/media/uhand uno-5/5-13.png" alt="5-13" style="width:500px"/>
</p>
<p style="text-align:center;"><strong>(10cm>距离>20cm)</strong></p>
<p align="center">
	<img src="../_static/media/uhand uno-5/5-14.png" alt="5-14" style="width:500px"/>
</p>
<p style="text-align:center;"><strong>(距离<10cm)</strong></p>

### 5.程序简要分析

本玩法程序名为“**uhand_ultrasonic_ranging.ino**”，关于程序的实现逻辑可参考下面的流程图：
<p align="center">
	<img src="../_static/media/uhand uno-5/5-15.png" alt="5-15" style="width:700px"/>
</p>


- ####  导入库文件

```c
#include <FastLED.h> //RGB控制库（需要导入库）
#include <Servo.h> //舵机库
#include "tone.h" //音调库
#include "Ultrasound.h" //发光超声波库
```

导入本玩法所需要的RGB控制库、舵机控制库以及控制发光超声波的库文件。

- #### 定义引脚及创建对象

首先定义了用于连接硬件的Arduino引脚，主要是六个舵机引脚、一个蜂鸣器引脚和一个RGB灯引脚。

```c
//按键引脚
const static uint8_t keyPins[2] = { 8, 9 };
// 舵机引脚
const static uint8_t servoPins[6] = { 7, 6, 5, 4, 3, 2 };
// 蜂鸣器引脚
const static uint8_t buzzerPin = 11;
// RGB灯引脚
const static uint8_t rgbPin = 13;
```

接着定义了用于控制RGB灯和舵机的变量。**extended_func_angles**数组用于存储每个舵机的期望角度，而**servo_angles**数组用于存储舵机的实际角度，范围是0~180。

```c
// RGB灯颜色对象
static CRGB rgbs[1];

// 舵机角度相关变量 （舵机下标对应的位置： 0-大拇指 1-食指 2-中指 3-无名指 4-小指 5-云台）
static uint8_t extended_func_angles[6] = { 90, 90, 90, 90, 90, 90 }; /* 二次开发例程使用的角度数值 */
static float servo_angles[6] = { 90, 90, 90, 90, 90, 90 };  /* 舵机实际控制的角度数值 */
```

对于期望值与实际值，可以看到loop主函数中调用的**servo_control**函数。

如果想要让舵机逐渐向目标位置靠近，则控制任务函数中需要调用到**servo_angles\[i\] = servo_angles\[i\] \* 0.85 + extended_func_angles\[i\] \* 0.15**这行代码。

这使得舵机每次都会以实际值的85%+期望值的15%来移动，从而实际值逐渐接近期望值，当等于期望值时，手掌就能够停止移动。

```c
// 舵机控制任务
void servo_control(void) {
  static uint32_t last_tick = 0;
  // 间隔25毫秒
  if (millis() - last_tick < 25) {
    return;
  }
  last_tick = millis();
  // 对6个舵机分别赋值
  for (int i = 0; i < 6; ++i) {
    servo_angles[i] = servo_angles[i] * 0.85 + extended_func_angles[i] * 0.15;
    servos[i].write(i == 0 || i == 5 ? 180 - servo_angles[i] : servo_angles[i]);
  }
}
```

创建了六个舵机控制对象和一个超声波对象，用于后续的控制和数据读取。声明任务函数，用于执行不同的控制任务。**servo_control**函数用于控制舵机，**tune_task**函数用于控制蜂鸣器，而**ultrasound_task**函数用于读取超声波传感器的数据。

```c
// 创建舵机控制对象
Servo servos[6];
// 创建超声波对象
Ultrasound ul;
// 舵机控制任务
static void servo_control(void);
// 蜂鸣器鸣响函数
void play_tune(uint16_t *p, uint32_t beat, uint16_t len);
// 蜂鸣器任务
void tune_task(void);
// 超声波任务
void ultrasound_task(void);
```

- #### 初始化设置

在**setup()** 函数中，主要是对相关的硬件设备进行初始化。首先是串口，将其通信的波特率设置为9600以及读取数据超时时间为500ms。

```c
void setup() {
  // 初始化串口并设置速率
  Serial.begin(9600);
  // 设置串行端口读取数据的超时时间
  Serial.setTimeout(500);
```

设置蜂鸣器的引脚设置为输出模式。

```c
  // 初始化蜂鸣器引脚
  pinMode(buzzerPin, OUTPUT);
```

绑定舵机IO口，方便通过引脚对其进行控制。

```c
  // 绑定舵机IO口
  for (int i = 0; i < 6; ++i) {
    servos[i].attach(servoPins[i]);
  }
```

使用FastLED库初始化扩展板上的RGB灯，并将其连接到rgbPin引脚。通过**rgbs\[0\] = CRGB(0, 255, 0)**设置RGB颜色为绿色。最后使用**FastLED.show**函数显示设置的颜色。

```c
  // 初始化RGB控制对象
  FastLED.addLeds<WS2812, rgbPin, GRB>(rgbs, 1);
  // 初始化颜色对象
  rgbs[0] = CRGB(0, 255, 0);
  // 根据颜色发光
  FastLED.show();
```

- #### 超声波检测

1. 初始化完成后，接下来将调用loop主函数中的超声波任务函数**ultrsound_task**，它是用于实现测距功能的。函数首先定义了变量**last_tick**，主要用于计算时间间隔。
2. 接着检查从上次调用**ultrasound_task**函数到现在是否已经过去了100毫秒。如果是，则执行下面的代码。否则，函数直接返回。而其中的**millis**函数是Arduino板启动以来的时间。通过这种方式，该函数可确保每100毫秒执行一次下面检测距离的任务。
3. 然后通过ul.Filter函数来获取滤波后的超声波距离值，并将结果存储在变量dis中。

```c
// 超声波任务
void ultrasound_task(void)
{
  static uint32_t last_tick = 0;
  // 间隔100ms
  if (millis() - last_tick < 100) {
    return;
  }
  last_tick = millis();

  // 获取超声波距离
  int dis = ul.Filter();

```

- #### 执行反馈

如果检测到障碍物距离大于200mm，则控制1~5号舵机转动到180°的位置，即张开手掌。同时通过**rgbs**函数和**ul.color**函数控制发光超声波模块和扩展板上的RGB灯显示为蓝色。

其中，rgbs.r、rgbs.g、rgbs.b代表扩展板上灯对应RGB三原色的亮度值，而ul.color（0,0,255,0,0,255）则代表发光超声波左右两个灯的RGB三原色亮度值。

```c
  // 若大于200mm
  if(dis >= 200)
  {
    //张开手掌
    for(int i = 0 ; i < 5 ; i++)
    {
      extended_func_angles[i] = 180;
    }
    // RGB灯蓝色
    rgbs[0].r = 0;
    rgbs[0].g = 0;
    rgbs[0].b = 255;
    FastLED.show();
    // 发光超声波蓝色
    ul.Color(0,0,255,0,0,255);
```

如果检测到障碍物距离小于50mm，那么将控制1~5号舵机转动至0°的位置，即闭合手掌。同时通过**rgbs**函数和**ul.color**函数控制发光超声波模块和扩展板上的RGB灯显示为红色。

```c
  }else if(dis <= 50 && dis >= 0) //若小于50mm
  {
    //闭合手掌
    for(int i = 0 ; i < 5 ; i++)
    {
      extended_func_angles[i] = 0;
    }
    // RGB红色
    rgbs[0].r = 255;
    rgbs[0].g = 0;
    rgbs[0].b = 0;
    FastLED.show();
    // 发光超声波红色
    ul.Color(255,0,0,255,0,0);
```

当障碍物距离在50mm到200mm之间，则通过**map**函数设置颜色RGB元素中的R和B根据dis的变化而变化，如**map(dis,50,200,255,0)**是将障碍物的距离dis映射到R元素上，其中dis的范围是50mm~200mm，R的亮度范围是255~0。

而对于舵机角度的映射亦可参考上述内容，同样是将障碍物的距离映射至舵机开合的角度范围（0~180°）。

```c
  }else{
    // 颜色根据距离变化而变化，越靠近R越大B越小，越远则反之
    int color[3] = {map(dis , 50 , 200 , 255 , 0),0,map(dis , 50 , 200 , 0 , 255)};
    // 各手指随距离越近越弯曲，越远越伸直
    uint8_t angles = map(dis , 50 , 200 , 0 , 180);
```

## 5.3声波抓球

本节通过发光超声波模块检测障碍物距离，控制机械手掌抓取及放置小球。

### 1.实现流程图

<p align="center">
	<img src="../_static/media/uhand uno-5/5-16.png" alt="5-16" style="width:700px"/>
</p>

### 2.程序下载

:::{Note}

下载程序前需先将蓝牙模块取下，否则会因串口冲突导致程序下载失败。

接入Type-B下载线时请将电池盒开关拨到“OFF”挡，避免下载线误碰到扩展板的电源引脚，造成短路

:::


找到并打开本节同目录下的“**02 程序文件 \uhand_ultrasonic_grasp\uhand_ultrasonic_grasp.ino**” **程序文件。

<p align="center">
<img src="../_static/media/uhand uno-5/5-17.png" alt="5-17" style="width:700px"/>
</p>

将Arduino通过UNO数据线（Type-B）连接至电脑。

<p align="center">
<img src="../_static/media/uhand uno-5/5-6.png" alt="5-6" style="width:700px"/>
</p>

点击”**选择开发板**“选项，软件会自动检测当前Arduino串口，点击进行连接。

<p align="center">
<img src="../_static/media/uhand uno-5/5-7.png" alt="5-7" style="width:700px"/>
</p>

点击<img src="../_static/media/uhand uno-5/5-8.png" alt="5-8" style="width:30px"/>，将程序下载至Arduino中，等待下载完成即可。

<p align="center">
<img src="../_static/media/uhand uno-5/5-9.png" alt="5-9" style="width:700px"/>
</p>

<p align="center">
<img src="../_static/media/uhand uno-5/5-10.png" alt="5-10" style="width:700px"/>
</p>

### 3.实现效果

1. 发光超声波模块未识别到障碍物时，机械手掌的云台保持在中位姿态。

<p align="center">
	<img src="../_static/media/uhand uno-5/5-18.png" alt="5-18" style="width:700px"/>
</p>

1. 识别到障碍物时，扩展板的蜂鸣器发出提示音，同时超声波模块及扩展板的RGB灯会切换为绿色。此时将小球放置于手掌中心，手掌会闭合抓取小球，转动至左侧放开（以手掌为第一视角），最后切换回识别状态。

<p align="center">
	<img src="../_static/media/uhand uno-5/5-19.png" alt="5-19" style="width:700px"/>
</p>


:::{Note}

放置动作结束后，需将障碍物移出发光超声波模块的检测范围，否则手掌将不会切换回识别状态。

:::


### 4.程序简要分析

本玩法程序名为“**uhand_ultrasonic_grasp.ino**”，关于程序的实现逻辑可参考下面的流程图：

<p align="center">
	<img src="../_static/media/uhand uno-5/5-20.png" alt="5-20" style="width:700px"/>
</p>

- #### 导入库文件

导入本玩法所需要的RGB控制库、舵机控制库以及控制发光超声波的库文件。

```c
#include <FastLED.h> //RGB控制库（需要导入库）
#include <Servo.h> //舵机库
#include "tone.h" //音调库
#include "Ultrasound.h" //发光超声波库
```

- #### 定义引脚及创建对象

1. 首先定义了用于连接硬件的Arduino引脚，主要是六个舵机引脚、一个蜂鸣器引脚和一个RGB灯引脚。

```c
//按键引脚
const static uint8_t keyPins[2] = { 8, 9 };
// 舵机引脚
const static uint8_t servoPins[6] = { 7, 6, 5, 4, 3, 2 };
// 蜂鸣器引脚
const static uint8_t buzzerPin = 11;
// RGB灯引脚
const static uint8_t rgbPin = 13;
```

2. 接着定义了用于控制RGB灯和舵机的变量。**extended_func_angles**数组用于存储每个舵机的期望角度，而**servo_angles**数组用于存储舵机的实际角度，范围是0~180。

```c
// RGB灯颜色对象
static CRGB rgbs[1];

// 舵机角度相关变量 （舵机下标对应的位置： 0-大拇指 1-食指 2-中指 3-无名指 4-小指 5-云台）
static uint8_t extended_func_angles[6] = { 120, 120, 120, 120, 120, 90 }; /* 二次开发例程使用的角度数值 */
static uint8_t servo_angles[6] = { 90, 90, 90, 90, 90, 90 };  /* 舵机实际控制的角度数值 */
```

对于期望值与实际值，可以看到loop主函数中调用的**servo_control**函数。

如果想要让舵机逐渐向目标位置靠近，则控制任务函数中需要调用到**servo_angles\[i\] = servo_angles\[i\] \* 0.85 + extended_func_angles\[i\] \* 0.15**这行代码。

这使得舵机每次都会以实际值的90%+期望值的10%来移动，从而实际值逐渐接近期望值，当等于期望值时，手掌就能够停止移动。

```c
// 舵机控制任务
void servo_control(void) {
  static uint32_t last_tick = 0;
  // 间隔25毫秒
  if (millis() - last_tick < 25) {
    return;
  }
  last_tick = millis();
  // 对6个舵机分别赋值
  for (int i = 0; i < 6; ++i) {
    servo_angles[i] = servo_angles[i] * 0.85 + extended_func_angles[i] * 0.15;
    servos[i].write(i == 0 || i== 5 ? 180 - servo_angles[i] : servo_angles[i]);
  }
}
```

3. 创建了六个舵机控制对象和一个超声波对象，用于后续的控制和数据读取。声明任务函数，用于执行不同的控制任务。**servo_control**函数用于控制舵机，**tune_task**函数用于控制蜂鸣器，而**ultrasound_task**函数用于读取超声波传感器的数据。

```c
// 创建舵机控制对象
Servo servos[6];

// 创建超声波对象
Ultrasound ul;

// 舵机控制任务
static void servo_control(void);
// 蜂鸣器鸣响函数
void play_tune(uint16_t *p, uint32_t beat, uint16_t len);
// 蜂鸣器任务
void tune_task(void);
// 超声波任务
void ultrasound_task(void);
```

- #### 初始化设置

1. 在**setup()** 函数中，主要是对相关的硬件设备进行初始化。首先是串口，将其通信的波特率设置为9600以及读取数据超时时间为500ms。

```c
void setup() {
  // 初始化串口并设置速率
  Serial.begin(9600);
  // 设置串行端口读取数据的超时时间
  Serial.setTimeout(500);
```

2. 设置蜂鸣器的引脚设置为输出模式。

```c
  // 初始化蜂鸣器引脚
  pinMode(buzzerPin, OUTPUT);
```

3. 绑定舵机IO口，方便通过引脚对其进行控制。

```c
  // 绑定舵机IO口
  for (int i = 0; i < 6; ++i) {
    servos[i].attach(servoPins[i]);
  }
```

4. 使用**FastLED**库初始化扩展板上的RGB灯，并将其连接到**rgbPin**引脚。通过**rgbs\[0\] = CRGB(0, 255, 0)**设置RGB颜色为绿色。最后再使用**FastLED.show**函数显示设置的颜色。

```c
  // 初始化RGB控制对象
  FastLED.addLeds<WS2812, rgbPin, GRB>(rgbs, 1);
  // 初始化颜色对象
  rgbs[0] = CRGB(0, 0, 255);
  // 根据颜色发光
  FastLED.show();
```

5. 通过**tone**和**noTone**函数设置蜂鸣器以1000Hz的频率短鸣一声后关闭。

```c
  // 蜂鸣器鸣响，频率1000Hz
  tone(buzzerPin, 1000);
  // 延时
  delay(100);
  // 蜂鸣器停止
  noTone(buzzerPin);
}
```



- #### 循环调用子函数

初始化完成后，进入loop主函数，依次循环调用“**ultrasound_task**”函数，检测超声波传感器与障碍物之间的距离，执行抓取或放置的操作；调用“**tune_task**”函数，执行蜂鸣器任务；调用“**servo_control**”函数，控制舵机。

```c
void loop() {
  // 超声波任务
  ultrasound_task();
  // 蜂鸣器鸣响任务
  tune_task();
  // 舵机控制
  servo_control();
}
```



- #### 超声波检测

1. 首先定义了变量**last_tick**，主要用于计算时间间隔；**posi**表示舵机的初始位置，初始值为90；**step**变量，跟踪当前任务执行的阶段；**delay_count = 0**表示延迟计数的值；**temp**变量为小球放置的标志位，为1时放下小球，为0时抓取小球。

```c
// 超声波任务
void ultrasound_task(void)
{
  static uint32_t last_tick = 0;
  static int posi = 100;
  static uint8_t step = 0;
  static uint8_t delay_count = 0;
  static uint8_t temp = 0;

```

2. 接着检查从上次调用**ultrasound_task**函数到现在是否已经过去了100毫秒。如果是，则执行下面的代码。否则，函数直接返回。而其中的 **millis()** 函数是Arduino控制板启动以来的时间。通过这种方式，该函数可确保每100毫秒执行一次下面检测距离的任务。

```c
  // 间隔100ms
  if (millis() - last_tick < 100) {
    return;
  }
  last_tick = millis();
```

3. 接着通过**ul.Filter**函数来获取经过滤波处理的超声波距离值，并将结果存储在变量dis中。

```c
  // 获取超声波距离
  int dis = ul.Filter();
```

4. 当获取到超声波模块检测的距离后，将进入到以下的控制过程。

case 0：判断当前障碍物的距离。是否大于或等于100mm，如果大于则让扩展板和发光超声波模块的RGB灯颜色亮蓝灯。

```c
    case 0: //判断超声波距离
      // 大于100mm
      
      if(dis >= 100)
      {
        extended_func_angles[5] = posi;
        // 蓝色
        rgbs[0].r = 0;
        rgbs[0].g = 0;
        rgbs[0].b = 255;
        FastLED.show();
        // 发光超声波蓝色
        ul.Color(0,0,255,0,0,255);
```

若与障碍物之间的距离小于100mm，则进入case1，让扩展板和发光超声波模块的RGB灯颜色亮绿灯，蜂鸣器短鸣一声。

```c
      }else if(dis >= 0){ // 若小于100mm且大于等于0，则跳入状态2
        step++;
        // 绿色
        rgbs[0].r = 0;
        rgbs[0].g = 255;
        rgbs[0].b = 0;
        FastLED.show();
        ul.Color(0,255,0,0,255,0);
        delay_count = 0;
        // 鸣响一声
        play_tune(DOC6, 300u, 1u);
      }
      break;
```

case 1：此时**delay_count**将开始计算，每个单位是100ms，当机械手掌等待1000ms后，判断temp是否为1，若为1则跳转到case4，若不为1则跳转到case2。

```c
    case 1:  //递小球与接小球的延时时间
      delay_count++;
      if(delay_count > 10)
      {
        step++;
        delay_count = 0;
      }
      break;
```

case 2：抓取小球，进入case3。

```c
    case 2://抓取
      extended_func_angles[0] = 11;
      extended_func_angles[1] = 31;
      extended_func_angles[2] = 56;
      extended_func_angles[3] = 43;
      extended_func_angles[4] = 29;
      delay_count = 0;
      step++;
      break;
```

case 3：等待500ms后（让手掌有足够的时间抓住小球），进入case6。

```c
    case 3: //等待一小会儿
      delay_count++;
      if(delay_count > 5)
      {
        step++;
        temp = 1;
        delay_count = 0;
      }
      break;
```

case 4：手掌云台舵机转向等待500ms，进入case5。

```c
    case 4:
      extended_func_angles[5] = 0;
      delay_count = 0;
      step++;
```

case 5 :手掌松开小球，等待500ms，云台舵机转向90度。

```c
    case 5: //等待一小会儿
      delay_count++;
      if(delay_count > 7)
      {
        step++;
        temp = 1;
        delay_count = 0;
      }
      break;
```

case 6：等待超声波前方无障碍物，回到case0（为了避免障碍物一直遮挡住超声波，导致玩法效果无法实现）。

```c
    case 6: //放开
      for(int i=0;i<5;i++)
        extended_func_angles[i] = 120;
      step++;
    break;
```

- #### 舵机控制

如果想要让舵机逐渐向目标位置靠近，则控制任务函数中需要调用到**servo_angles\[i\] = servo_angles\[i\] \* 0.85 + extended_func_angles\[i\] \* 0.15**这行代码。

这使得舵机在每次都会以实际值的90%+期望值的10%来移动，从而使实际值逐渐接近期望值，当等于期望值时，手掌就能够停止移动。

```c
// 舵机控制任务
void servo_control(void) {
  static uint32_t last_tick = 0;
  // 间隔25毫秒
  if (millis() - last_tick < 25) {
    return;
  }
  last_tick = millis();
  // 对6个舵机分别赋值
  for (int i = 0; i < 6; ++i) {
    servo_angles[i] = servo_angles[i] * 0.85 + extended_func_angles[i] * 0.15;
    servos[i].write(i == 0 || i== 5 ? 180 - servo_angles[i] : servo_angles[i]);
  }
}
```

- #### 蜂鸣器控制

控制蜂鸣器按照指定的节奏和音调数组播放旋律。

```c
// 蜂鸣器任务
void tune_task(void) {
```

1. 声明变量，**l_tune_beat**变量，用于存储上一次播放音调的间隔时间（以毫秒为单位）；**last_tick**变量，用于存储上一次函数执行的时间戳。控制蜂鸣器按照指定的节奏和音调数组播放旋律。

```c
  static uint32_t l_tune_beat = 0;
  static uint32_t last_tick = 0;
```

2. 判断是否需要播放音调，使用 **millis()** 函数获取当前的时间戳，并与 **last_tick** 进行比较。如果当前时间与上一次播放音调的时间间隔小于 **l_tune_beat**，并且 tune_beat 的值没有变化（即 **tune_beat** 与 **l_tune_beat** 相等），则函数直接返回，不执行任何操作。这是为了防止在相同的间隔时间内重复播放相同的音调。

```c
// 若未到定时时间 且 响的时间跟上一次的一样
  if (millis() - last_tick < l_tune_beat && tune_beat == l_tune_beat) {
    return;
  }
```

3. 更新变量，将 **tune_beat** 的值赋给 **l_tune_beat**；更新 **last_tick** 为当前时间戳。

```c
  l_tune_beat = tune_beat;
  last_tick = millis();
```

4. 如果 **tune_num** 大于 0，表示还有剩余的音调需要播放，使用 **tone()** 函数在 **buzzerPin** 引脚上播放当前音调。

```c
  // 若还有音调
  if (tune_num > 0) {
    tune_num -= 1;
    tone(buzzerPin, *tune++);
```

5. 如果 **tune_num** 不大于 0，表示所有的音调都已经播放完毕；使用 **noTone()** 函数停止蜂鸣器发声；重置 **tune_beat** 和 **l_tune_beat** 为 10（可能是默认的播放间隔），准备下一次播放旋律。

```c
  } else { //无则暂停
    noTone(buzzerPin);
    tune_beat = 10;
    l_tune_beat = 10;
  }
}
```

- #### 蜂鸣器发声控制

指定要播放的音调数组、播放音调的间隔以及要播放的音调数量。

```c
// 蜂鸣器鸣响函数 参数1：音调组，参数2：音调鸣响时间，参数3：音调组元素个数
void play_tune(uint16_t *p, uint32_t beat, uint16_t len) {
  tune = p;
  tune_beat = beat;
  tune_num = len;
}
```

**tune = p**;将变量 **tune**（是一个指向音调数组的指针）设置为传入的参数 **p** 的值。这样，**tune** 就指向了用户提供的音调数组。

**tune_beat = beat**;将变量 **tune_beat**（表示播放音调的间隔）设置为传入的参数 **beat** 的值。这决定了音调的播放节奏。

**tune_num = len**;将变量 **tune_num**（表示要播放的音调的数量）设置为传入的参数 **len** 的值。这确定了播放列表的长度。



## 5.4 数手指

本节通过读取触摸传感器被按下的次数来控制机械手掌上手指张开的数量。

### 1.实现流程图

<p align="center">
	<img src="../_static/media/uhand uno-5/5-21.png" alt="5-21" style="width:700px"/>
</p>

### 2.触摸传感器

<p align="center">
	<img src="../_static/media/uhand uno-5/5-22.png" alt="5-22" style="width:300px"/>
</p>

这是一款基于电容感应原理的触摸传感器，该传感器上主要通过镀金接触面感应人体或者金属。

- #### 传感器工作原理

当无任何人体或金属触碰到金属面时，信号端输出高电平；当人体或金属触碰到金属面时，信号端输出的是低电平。此外，隔着一定厚度的塑料、纸张等材料的接触也可以被感应到，且感应的灵敏度与接触面的大小和覆盖材料的厚度有关。

- #### 传感器原理图

在不触摸金属片的情况下，C2电容充满电，Touch输出高电平；当人体触碰到金属片会将C2电容中电压释放掉，这时Touch输出低电平。

<p align="center">
	<img src="../_static/media/uhand uno-5/5-23.png" alt="5-23" style="width:700px"/>
</p>

- **供电电压：5V**
- **工作电流：2mA**
- **接口型号：5264-4AW**







- #### 传感器接线

将触摸传感器通过4Pin线接入D10、D12号接口，如下图：

<p align="center">
	<img src="../_static/media/uhand uno-5/5-24.png" alt="5-24" style="width:700px"/>
</p>

### 3.程序下载

:::{Note}

下载程序前需先将蓝牙模块取下，否则会因串口冲突导致程序下载失败。

接入Type-B下载线时请将电池盒开关拨到“OFF”挡，避免下载线误碰到扩展板的电源引脚，造成短路。

:::

1. 找到并打开本节同目录下的“**02 程序文件 uhand_count_finger\uhand_count_finger.ino**”程序文件。

<p align="center">
<img src="../_static/media/uhand uno-5/5-25.png" alt="5-25" style="width:700px"/>
</p>

2. 将Arduino通过UNO数据线（Type-B）连接至电脑。

<p align="center">
<img src="../_static/media/uhand uno-5/5-6.png" alt="5-6" style="width:700px"/>
</p>

3. 点击“**选择开发板**”选项，软件会自动检测当前Arduino串口，点击进行连接。

<p align="center">
<img src="../_static/media/uhand uno-5/5-7.png" alt="5-7" style="width:700px"/>
</p>

4. 点击<img src="../_static/media/uhand uno-5/5-8.png" alt="5-8" style="width:30px"/>，将程序下载至Arduino中，等待下载完成即可。

<p align="center">
	<img src="../_static/media/uhand uno-5/5-9.png" alt="5-9" style="width:700px"/>
</p>


<p align="center">
	<img src="../_static/media/uhand uno-5/5-10.png" alt="5-10" style="width:700px"/>
</p>

### 4.实现效果

1. 打开机械手掌电源后，机械手掌云台回到中位，五指紧握，同时扩展板上的RGB灯亮绿色。

<p align="center">
	<img src="../_static/media/uhand uno-5/5-26.png" alt="5-26" style="width:500px"/>
</p>

2. 当按下触摸传感器上的金属面时，传感器的蓝色LED灯短亮，同时大拇指张开；再次按下则食指张开，以此类推。

<p align="center">
	<img src="../_static/media/uhand uno-5/5-27.png" alt="5-27" style="width:500px"/>
</p>

3. 当五指全部张开时，再次按下触摸传感器，则五指全部紧握，重新开始计数。

<p align="center">
	<img src="../_static/media/uhand uno-5/5-28.png" alt="5-28" style="width:500px"/>
</p>

### 5.程序简要分析

本玩法程序名为“**uhand_count_finger.ino**”，关于程序的实现逻辑可参考下面的流程图：

<p align="center">
	<img src="../_static/media/uhand uno-5/5-29.png" alt="5-29" style="width:700px"/>
</p>

- #### 导入库文件

导入本玩法所需要的RGB控制库以及舵机控制库、蜂鸣器的音调库文件。

```c
#include <FastLED.h> //RGB控制库（需要导入库）
#include <Servo.h> //舵机库
#include "tone.h" //音调库
```

- #### 定义引脚及创建对象

1. 首先定义了用于连接硬件的Arduino引脚，主要是触摸传感器的引脚、六个舵机引脚、一个蜂鸣器引脚和一个RGB灯引脚。

```c
#define Touch_pin 12  //定义触摸传感器的信号端接控制板的数字口2
```

```c
//按键引脚
const static uint8_t keyPins[2] = { 8, 9 };
// 舵机引脚
const static uint8_t servoPins[6] = { 7, 6, 5, 4, 3, 2 };
// 蜂鸣器引脚
const static uint8_t buzzerPin = 11;
// RGB灯引脚
const static uint8_t rgbPin = 13;
```

2. 接着定义了用于控制RGB灯和舵机的变量。**extended_func_angles**数组用于存储每个舵机的期望角度，而**servo_angles**数组用于存储舵机的实际角度，范围是0~180，这里是设置了手掌初始位置为闭合。

```c
// RGB灯颜色对象
static CRGB rgbs[1];

// 舵机角度相关变量 （舵机下标对应的位置： 0-大拇指 1-食指 2-中指 3-无名指 4-小指 5-云台）
static uint8_t extended_func_angles[6] = { 0,0,0,0,0,90 }; /* 二次开发例程使用的角度数值 */
static float servo_angles[6] = { 0,0,0,0,0,90 };  /* 舵机实际控制的角度数值 */
```

对于期望值与实际值，可以看到**loop**主函数中调用的**servo_control**函数。

如果想要让舵机逐渐向目标位置靠近，则控制任务函数中需要调用到**servo_angles\[i\] = servo_angles\[i\] \* 0.85 + extended_func_angles\[i\] \* 0.15**这行代码。

这使得舵机每次都会以实际值的85%+期望值的15%来移动，从而实际值逐渐接近期望值，当等于期望值时，手掌就能够停止移动。

```c
// 舵机控制任务
void servo_control(void) {
  static uint32_t last_tick = 0;
  // 间隔25毫秒
  if (millis() - last_tick < 25) {
    return;
  }
  last_tick = millis();
  // 对6个舵机分别赋值
  for (int i = 0; i < 6; ++i) {
    servo_angles[i] = servo_angles[i] * 0.85 + extended_func_angles[i] * 0.15;
    servos[i].write(i == 0 || i == 5 ? 180 - servo_angles[i] : servo_angles[i]);
  }
}
```

3. 创建了六个舵机控制对象，用于后续的控制和数据读取。声明任务函数，用于执行不同的控制任务。**servo_control**函数用于控制舵机，**play_tune**用于控制蜂鸣器鸣响，**tune_task**函数用于执行蜂鸣器任务，**touch_task**函数用于执行触摸传感器任务。

```c
// 创建舵机控制对象
Servo servos[6];
// 舵机控制任务
static void servo_control(void);
// 蜂鸣器鸣响函数
void play_tune(uint16_t *p, uint32_t beat, uint16_t len);
// 蜂鸣器任务
void tune_task(void);
// 触摸传感器任务
void touch_task(void);
```

- #### 初始化设置

1. 在**setup()** 函数中，主要是对相关的硬件设备进行初始化。首先是串口，将其通信的波特率设置为9600以及读取数据超时时间为500ms。

```c
void setup() {
  // 初始化串口并设置速率
  Serial.begin(9600);
  // 设置串行端口读取数据的超时时间
  Serial.setTimeout(500);
```

2. 设置蜂鸣器的引脚为输出模式。

```c
  // 初始化蜂鸣器引脚
  pinMode(buzzerPin, OUTPUT);
```

3. 绑定舵机IO口，方便通过引脚对其进行控制。

```c
  // 绑定舵机IO口
  for (int i = 0; i < 6; ++i) {
    servos[i].attach(servoPins[i],500,2500);
  }
```

4. 使用**FastLED**库初始化扩展板上的RGB灯，并连接到**rgbPin**引脚。通过**rgbs\[0\] = CRGB(0, 255, 0)**设置颜色为绿色，使用**FastLED.show**函数显示设置的颜色。控制蜂鸣器短鸣一声后停止，最后将触摸传感器设置为输入模式，用于读取传感器金属面的反馈值。

```c
  // 初始化RGB控制对象
  FastLED.addLeds<WS2812, rgbPin, GRB>(rgbs, 1);
  // 初始化颜色对象
  rgbs[0] = CRGB(0, 255, 0);
  // 根据颜色发光
  FastLED.show();
  // 蜂鸣器鸣响，频率1000Hz
  tone(buzzerPin, 1000);
  // 延时
  delay(100);
  // 蜂鸣器停止
  noTone(buzzerPin);
  pinMode(Touch_pin, INPUT);//将TOUCH配置为输入(输入状态一般是将要读取这个引脚的状态，即读取传感器的反馈值）
}
```

- #### 触摸检测

1. 初始化完成后，接下来将调用**loop**主函数中的触摸按键任务函数**touch_task**，它是用于处理触摸传感器的数据并控制舵机移动的。
2. 首先定义了变量**last_tick**，主要用于计算时间间隔；**posi**表示云台舵机的初始位置，初始值为90；**step = 0**标识当前运行流程的阶段；**delay_count = 0**表示延迟计数的值；**finger**则代表手掌上的手指序号。
3. 接着检查从上次调用**touch_task**函数到现在是否已经过去了40毫秒。如果是，则执行下面的代码。否则，函数直接返回。而其中的**millis()**函数是Arduino板启动以来的时间。通过这种方式，该函数可确保每40毫秒执行一次下面检测触摸传感器的任务。
4. 通过**digitalRead**函数定义触摸传感器金属面被按下时数据为0，未被按下为1。

```c
// 触摸按键任务
void touch_task(void)
{
  static uint32_t last_tick = 0;
  static int posi = 90;
  static uint8_t step = 0;
  static uint8_t delay_count = 0;
  static uint8_t finger = 0;
  
  // 间隔40ms
  if (millis() - last_tick < 40) {
    return;
  }
  last_tick = millis();

  //按下为 0 ，松开为 1 
  uint8_t touch_value = digitalRead(Touch_pin);
```

- #### 执行反馈

1. 程序中分为两种情况，一是触摸传感器被按下（case 0），另一种是松开触摸传感器（case 1）。

当触摸传感器被按下时，由于默认状态下五指为闭合。通过**finger = (finger + 1) > 5 ? 0 : finger + 1**这行代码**finger**参数会增加1，这使得对应的1号大拇指会张开，同时蜂鸣器会短鸣一声。扩展板上的RGB灯也会亮蓝色，直至松开触摸传感器。

而在多次按下之后，此时五个手指已全部张开，当再次按下触摸传感器后。由于此时**finger**参数再自增1大于5，对应的参数就会被重置为0，因此所有的手指将会通过**extended_func_angles**函数被设置为闭合状态。

```c
      if(touch_value == 0) //若按下
      {
        // 若finger为5时，表示已经全部张开了，要闭合手掌
        if(finger < 5)
        {
          extended_func_angles[finger] = 180;
        }else{ //弯曲当前的手指
          for(int i = 0 ; i < 5 ; i++)
          {
            extended_func_angles[i] = 0;
          }
        }
        // 若finger大于5时，则为0，否则+1
        finger = (finger + 1) > 5 ? 0 : finger + 1;
        // 鸣响一声
        play_tune(DOC6, 100, 1);
        // RGB灯蓝色
        rgbs[0].r = 0;
        rgbs[0].g = 0;
        rgbs[0].b = 250;
        FastLED.show();
        // 跳入下一状态
        step++;
      }
```

2. 当松开触摸传感器后，程序将进入case 1状态，此时扩展板上的RGB灯亮常亮绿色，等待下次触摸传感器按下后发出信号再进行切换。

```c
    case 1: //若松开，则回到状态0
      if(touch_value == 1) //若松开
      {
        // RGB灯绿色
        rgbs[0].r = 0;
        rgbs[0].g = 250;
        rgbs[0].b = 0;
        FastLED.show();
        // 回到状态0
        step = 0;
      }
      break;
```

## 5.5 姿态控制

本节通过读取加速度传感器的X、Y轴的状态来控制机械手掌抓取与放置物品。

### 1.实现流程图

<p align="center">
	<img src="../_static/media/uhand uno-5/5-30.png" alt="5-30" style="width:700px"/>
</p>

### 2.加速度传感器

<p align="center">
	<img src="../_static/media/uhand uno-5/5-31.png" alt="5-31" style="width:400px"/>
</p>

该传感器主要用到了 MPU6050 传感器元件。它集成了3 轴 MEMS 陀螺仪，3 轴 MEMS 加速度计，以及一个可扩展的数字运动处理器 DMP（ DigitalMotion Processor）。

- #### 传感器工作原理

传感器对陀螺仪和加速度计分别用了三个 16 位的 ADC，将其测量的模拟量转化为可输出的数字量。为了精确跟踪快速和慢速的运动，传感器的测量范围都是用户可控的，陀螺仪可测范围为±250，±500，±1000，±2000°/秒（ dps），加速度计可测范围为±2，±4，±8，±16g。

传感器倾斜方向对应X-Y轴的值如下所示：

<p align="center">
	<img src="../_static/media/uhand uno-5/5-32.png" alt="5-32" style="width:400px"/>
</p>

- #### 传感器原理图

传感器通过MPU6050芯片控制，其组合3轴MEMS陀螺仪和加速度计值。

<p align="center">
	<img src="../_static/media/uhand uno-5/5-33.png" alt="5-33" style="width:700px"/>
</p>

- #### 传感器接线

将加速度传感器通过4Pin线接入任意IIC接口。

<p align="center">
	<img src="../_static/media/uhand uno-5/5-34.png" alt="5-34" style="width:700px"/>
</p>


### 3.程序下载

:::{Note}

下载程序前需先将蓝牙模块取下，否则会因串口冲突导致程序下载失败。

接入Type-B下载线时请将电池盒开关拨到“OFF”挡，避免下载线误碰到扩展板的电源引脚，造成短路。

:::


1. 找到并打开本节同目录下“**02 程序文件\\uhand_IMU\\uhand_IMU.ino**”程序文件。

<p align="center">
	<img src="../_static/media/uhand uno-5/5-35.png" alt="5-35" style="width:700px"/>
</p>

2. 将Arduino通过UNO数据线（Type-B）连接至电脑。

<p align="center">
<img src="../_static/media/uhand uno-5/5-6.png" alt="5-6" style="width:700px"/>
</p>

3. 点击“**选择开发板**”选项，软件会自动检测当前Arduino串口，点击进行连接。

<p align="center">
<img src="../_static/media/uhand uno-5/5-7.png" alt="5-7" style="width:700px"/>
</p>

4. 点击<img src="../_static/media/uhand uno-5/5-8.png" alt="5-8" style="width:30px"/>，将程序下载至Arduino中，等待下载完成即可。

<p align="center">
	<img src="../_static/media/uhand uno-5/5-9.png" alt="5-9" style="width:700px"/>
</p>

<p align="center">
	<img src="../_static/media/uhand uno-5/5-10.png" alt="5-10" style="width:700px"/>
</p>

### 4.实现效果

1. 打开机械手掌电源后，机械手掌云台回到中位，五指张开，同时扩展板上的RGB灯亮绿色。

<p align="center">
	<img src="../_static/media/uhand uno-5/5-36.png" alt="5-36" style="width:500px"/>
</p>

2. 当加速度传感器上的X的值＞40（以加速度传感器为第一视角，加速度传感器向下倾斜），此时手掌会紧握。

<p align="center">
	<img src="../_static/media/uhand uno-5/5-37.png" alt="5-37" style="width:500px"/>
</p>

3. 当加速度传感器上的Y的值＞50（以加速度传感器为第一视角，加速度传感器向左倾斜），此时手掌云台向左旋转，手指张开。

<p align="center">
	<img src="../_static/media/uhand uno-5/5-38.png" alt="5-38" style="width:500px"/>
</p>

4. 当加速度传感器上的Y的值＜-50（以加速度传感器为第一视角，加速度传感器向右倾斜），此时手掌云台向右旋转，手指张开。

<p align="center">
	<img src="../_static/media/uhand uno-5/5-39.png" alt="5-39" style="width:500px"/>
</p>

### 5.程序简要分析

本玩法程序名为“**uhand_IMU.ino**”，关于程序的实现逻辑可参考下面的流程图：

<p align="center">
	<img src="../_static/media/uhand uno-5/5-40.png" alt="5-40" style="width:700px"/>
</p>

- #### 导入库文件

导入本玩法所需要的RGB控制库以及舵机控制库、蜂鸣器的音调库、MPU6050（加速度传感器）库、动作组任务库文件。

```c
#include <FastLED.h> //导入LED库
#include <Servo.h> //导入舵机库
#include "tone.h" //音调库
#include <MPU6050.h>
#include "uhand_servo.h"
```

- #### 定义引脚及创建对象

1. 首先声明了MPU6050传感器相关的变量。定义MPU6050对象，定义存储加速度计和陀螺仪、以及倾角的变量。

```c
MPU6050 accelgyro;
int16_t ax, ay, az;
int16_t gx, gy, gz;
float ax0, ay0, az0;
float gx0, gy0, gz0;
float ax1, ay1, az1;
float gx1, gy1, gz1;

float dx;
float dz;
int ax_offset, ay_offset, az_offset, gx_offset, gy_offset, gz_offset;
float radianX;
float radianY;
float radianZ;
float radianX_last; //最终获得的X轴倾角
float radianY_last; //最终获得的Y轴倾角

const static uint16_t DOC5[] = { TONE_C5 };
const static uint16_t DOC6[] = { TONE_C6 };
```

2. 接着定义了用于连接硬件的Arduino引脚，主要是六个舵机引脚、一个蜂鸣器引脚和一个RGB灯引脚。

```c
/* 引脚定义 */
const static uint8_t servoPins[6] = { 7, 6, 5, 4, 3, 2 };
const static uint8_t buzzerPin = 11;
const static uint8_t rgbPin = 13;
```

3. 然后定义了用于控制RGB灯和舵机的变量，以及用于控制动作组的变量。

```c
//动作组控制对象
HW_ACTION_CTL action_ctl;
//RGB灯控制对象
static CRGB rgbs[1];
//舵机控制对象
Servo servos[6];

// 舵机角度相关变量
static float servo_angles[6] = { 130,130,130,130,130,90 };  /* 舵机实际控制的角度数值 */
```

4. 在“**uhand_servo.h**”文件中**extended_func_angles**数组用于存储每个舵机的期望角度， **action_num**用于控制当前需运行的动作组。

```c
class HW_ACTION_CTL{
  public:
    uint8_t extended_func_angles[6] = { 130,130,130,130,130, 90 }; /* 二次开发例程使用的角度数值 */
    //控制执行动作组
    void action_set(int num);
    int action_state_get(void);
    void action_task(void);
    
  private:
    //动作组控制变量
    int action_num = 0;
};
```

5. 在“**actions.h**”文件中，宏定义**action_count**用于设置当前动作组的数量，而action是一个三维数组，用于存储手掌的抓取与向左放置。向右放置等三个动作组。

```c
#define action_count 3 //动作组数量

static uint8_t action[action_count][20][7] = 
    {
      //动作组1-抓握
      {{1,130,130,130,130,130,90},{1,20,40,40,40,40,90},{0,0,0,0,0,0}},
      //动作组2-向右分拣
      {{1,20,40,40,40,40,180},{1,130,130,130,130,130,180},{1,130,
      130,130,130,130,180},{1,130,130,130,130,130,90},{0,0,0,0,0,0}},
      //动作组3-向左分拣
      {{1,20,40,40,40,40,0},{1,130,130,130,130,130,0},{1,130,
      130,130,130,130,0},{1,130,130,130,130,130,90},{0,0,0,0,0,0}}
    };
```

对于期望值与实际值，可以看到loop主函数中调用的**servo_control**函数。

如果想要让舵机逐渐向目标位置靠近，则控制任务函数中需要调用到**servo_angles\[i\] = servo_angles\[i\] \* 0.90 + extended_func_angles\[i\] \* 0.1**这行代码。

这使得舵机每次都会以实际值的90%+期望值的10%来移动，从而实际值逐渐接近期望值，当等于期望值时，手掌就能够停止移动。

```c
//舵机控制任务
void servo_control(void) {
  static uint32_t last_tick = 0;
  if (millis() - last_tick < 20) {
    return;
  }
  last_tick = millis();
  for (int i = 0; i < 6; ++i) {
    servo_angles[i] = servo_angles[i] * 0.90 + action_ctl.extended_func_angles[i] * 0.10;
    servos[i].write(i == 0 || i == 5 ? 180 - servo_angles[i] : servo_angles[i]);
  }
}
```

6. 定义了用于控制蜂鸣器的变量，并声明任务函数，用于执行不同的控制任务。**servo_control**函数用于控制舵机；**play_tune**用于控制蜂鸣器鸣响；**tune_task**函数用于执行蜂鸣器任务，**user_task**函数用于检测加速度传感器的状态，执行抓取或放置的操作； **update_mpu6050**函数用于更新加速度传感器的倾角数据。

```c
// 蜂鸣器相关变量
static uint16_t tune_num = 0;
static uint32_t tune_beat = 10;
static uint16_t *tune;

static void servo_control(void); /* 舵机控制 */
void play_tune(uint16_t *p, uint32_t beat, uint16_t len); /* 蜂鸣器控制接口 */
void tune_task(void); /* 蜂鸣器控制任务 */
void user_task(void); /* 用户任务 */

void update_mpu6050(void); /*更新倾角传感器数据*/
```

- #### 初始化设置

1. 在**setup()** 函数中，主要是对相关的硬件设备进行初始化。首先是串口，将其通信的波特率设置为115200以及读取数据超时时间为500ms。

```c
void setup() {
  Serial.begin(115200);
  // 设置串行端口读取数据的超时时间
  Serial.setTimeout(500);
```

2. 绑定舵机IO口，方便通过引脚对其进行控制。

```c
  // 绑定舵机IO口
  for (int i = 0; i < 6; ++i) {
    servos[i].attach(servoPins[i],500,2500);
  }
```

3. 使用**FastLED**库初始化扩展板上的RGB灯，并连接到**rgbPin**引脚。通过**rgbs\[0\] = CRGB(0, 0, 100)**设置颜色为蓝色，使用**FastLED.show**函数显示设置的颜色。

```c
  //RGB灯初始化并控制
  FastLED.addLeds<WS2812, rgbPin, GRB>(rgbs, 1);
  rgbs[0] = CRGB(0, 100, 0);
  FastLED.show();
```

4. 设置蜂鸣器的引脚为输出模式，控制蜂鸣器短鸣一声后停止。

```c
  //蜂鸣器初始化并鸣响一声
  pinMode(buzzerPin, OUTPUT);
  tone(buzzerPin, 1000);
  delay(100);
  noTone(buzzerPin);
```

5. 初始化IIC通信以及MPU6050传感器，设置陀螺仪和加速度计的量程。其中陀螺仪通过传递传输3实现的，加速度计通过传递参数1实现的。

```c
  //MPU6050 配置
  Wire.begin();
  accelgyro.initialize();  
  accelgyro.setFullScaleGyroRange(3); //设定角速度量程
  accelgyro.setFullScaleAccelRange(1); //设定加速度量程
  delay(200);
```

6. 读取传感器数据，用于后续的校准过程。

```c
  accelgyro.getMotion6(&ax, &ay, &az, &gx, &gy, &gz);  //获取当前各轴数据以校准
```

7. 对数据进行校准，消除由于传感器安装不水平，或电子偏移引起的误差。

```c
  ax_offset = ax;  //X轴加速度校准数据
  ay_offset = ay;  //Y轴加速度校准数据
  az_offset = az - 8192;  //Z轴加速度校准数据
  gx_offset = gx; //X轴角速度校准数据
  gy_offset = gy; //Y轴角速度校准数据
  gz_offset = gz; //Z轴教书的校准数据
```

8. 通过串口输出“Start”字符串，表明传感器已经做好准备，并开始传输数据了。

```c
  delay(1000);
  Serial.println("start");
```

- #### 循环调用子函数

初始化完成后，进入loop主函数，依次循环调用“**user_task**”函数，检测加速度传感器的状态，执行抓取或放置的操作；调用“**tune_task**”函数，执行蜂鸣器任务；调用“**servo_control**”函数，控制舵机；调用“**action_ctl.action_task**”函数，进行动作组调用；调用“**update_mpu6050**”函数，更新加速度传感器的倾角数据。

```c
void loop() {
  // 用户任务
  user_task();
  // 蜂鸣器鸣响任务
  tune_task();
  // 舵机控制
  servo_control();
  // 动作组运动任务
  action_ctl.action_task();

  update_mpu6050();
}
```

- #### 加速度传感器状态检测

定义“**user_task**”函数，进行加速度传感器的状态检测，若加速度传感器向前倾斜，则执行抓取的动作组，向左倾斜执行放置左边的动作组，向右倾斜执行放置右边的动作组。

```c
// 用户任务
void user_task(void)
{
```

1. 首先定义**last_tick**变量，用于记录上一次任务执行的时间点；step变量，跟踪当前任务执行的阶段；**act_num**变量，存储要执行的动作组编号；**delay_count**变量设置LED灯的颜色。

```c
  static uint32_t last_tick = 0;
  static uint8_t step = 0;
  static uint8_t act_num = 0;
  static uint32_t delay_count = 0;
  int color = 0;
```

2. 如果距离上一次执行时间不足100ms，则直接返回，避免任务过于频繁执行；调用**millis()**函数更新上一次任务执行的时间点。

```c
  // 时间间隔100ms
  if (millis() - last_tick < 100) {
    return;
  }
  last_tick = millis();
```

3. 根据加速度传感器的倾斜方向和角度，调用相应动作组。

```c
  switch(step)
  {
```

case 0：检测加速度传感器的X轴方向是否大于40。如果是，则设置LED为红色，播放声音，设置动作组编号为1，并转移到下一个状态。如果不是，则关闭LED。

```c
case 0:
      if(radianX_last > 40) //抓取
      {
        rgbs[0].r = 100; //红色
        rgbs[0].g = 0;
        rgbs[0].b = 0;
        FastLED.show();
        play_tune(DOC6, 300u, 1u);
        // 需要运行动作组1
        act_num = 1;
        step++;
      }else{ //若没识别到
        rgbs[0].r = 0;
        rgbs[0].g = 100; //绿色
        rgbs[0].b = 0;
        FastLED.show();
      }
      break;
```

case 1：等待1秒然后调用“**action_ctl.action_set()**”函数设置动作组编号为之前保存的act_num。

```c
    case 1: //等待1s
      delay_count++;
      if(delay_count > 5)
      {
        delay_count = 0;
        // 运行动作组1-抓握
        action_ctl.action_set(act_num);
        act_num = 0;
        step++;
      }
      break;
```

case 2：等待动作状态清零，调用“**action_ctl.action_state_get()**”函数来获取当前运行的动作组**action_num**，如果**action_num为0**，则转移到下一个状态。

```c
    case 2: //等待动作状态清零
      if(action_ctl.action_state_get() == 0)
      {
        step++;
      }
      break;
```

case 3：检测加速度Y轴方向是否大于50。如果是，则设置LED为绿色，播放声音，并通过“**action_ctl.action_set()**”函数设置动作组编号为2，然后转移到下一个状态。

```c
    case 3:
      if(radianY_last > 50) //右边
      {
        rgbs[0].r = 0; 
        rgbs[0].g = 100;//绿色
        rgbs[0].b = 0;
        FastLED.show();
        play_tune(DOC6, 300u, 1u);
        // 需要运行动作组2进行分拣
        action_ctl.action_set(2);
        step++;
```

如果加速度Y轴方向是小于-50，则设置LED为蓝色，播放声音，并设置动作组编号为3，然后转移到下一个状态。

```c
      }else if(radianY_last < -50) //左边
      {
        rgbs[0].r = 0; 
        rgbs[0].g = 0;
        rgbs[0].b = 100;//蓝色
        FastLED.show();
        play_tune(DOC6, 300u, 1u);
        // 需要运行动作组3
        action_ctl.action_set(3);
        step++;
      }
      break;
```

case 4：再次等待动作状态清零。如果**action_num**为0，则关闭所有LED并重置状态机到初始状态。

```c
    case 4: //等待动作状态清零
      if(action_ctl.action_state_get() == 0)
      {
        FastLED.clear();
        step = 0;
      }
      break;
    default:
      step = 0;
      break;
  }
}
```

- #### 更新加速度传感器倾角的数据

从MPU6050传感器读取加速度和角速度数据，进行滤波和校正，然后使用这些数据来计算并更新x轴和y轴的倾角。

```c
//更新倾角传感器数据
void update_mpu6050(void)
{
```

1. 首先定义定时器变量“timer_u”。

```c
  static uint32_t timer_u;
```

2. 然后检查**timer_u**是否小于当前的时间，若是，则执行括号内的代码。

```c
  if (timer_u < millis())
  {
```

3. 更新定时器，将**timer_u**设置为当前时间加上20毫秒。这意味着**update_mpu6050**函数每20毫秒执行一次；读取传感器数据，从**accelgyro**对象（可能是MPU6050的实例）读取6个运动参数：3个加速度值（ax, ay, az）和3个角速度值（gx, gy, gz）。

```c
    timer_u = millis() + 20;
    accelgyro.getMotion6(&ax, &ay, &az, &gx, &gy, &gz);
```

4. 对读取的加速度数据进行滤波处理，平滑数据中的噪声。这里使用了简单的RC滤波器。

```c
    ax0 = ((float)(ax)) * 0.3 + ax0 * 0.7;  //对读取到的值进行滤波
    ay0 = ((float)(ay)) * 0.3 + ay0 * 0.7;
    az0 = ((float)(az)) * 0.3 + az0 * 0.7;
```

5. 将滤波后的加速度数据减去偏移量，并除以8192（传感器数据的缩放因子），以将其转换为重力加速度的倍数。

```c
    ax1 = (ax0 - ax_offset) /  8192.0;  // 校正，并转为重力加速度的倍数
    ay1 = (ay0 - ay_offset) /  8192.0;
    az1 = (az0 - az_offset) /  8192.0;
```

6. 对读取的角速度数据进行滤波处理。

```c
    gx0 = ((float)(gx)) * 0.3 + gx0 * 0.7;  //对读取到的角速度的值进行滤波
    gy0 = ((float)(gy)) * 0.3 + gy0 * 0.7;
    gz0 = ((float)(gz)) * 0.3 + gz0 * 0.7;
```

7. 将滤波后的角速度数据减去偏移量。

```c
    gx1 = (gx0 - gx_offset);  //校正角速度
    gy1 = (gy0 - gy_offset);
    gz1 = (gz0 - gz_offset);
```

8. 使用atan2函数计算x轴和y轴的倾角（弧度值）。将弧度值转换为角度值。

```c
    //互补计算x轴倾角
    radianX = atan2(ay1, az1);
    radianX = radianX * 180.0 / 3.1415926;
    float radian_temp = (float)(gx1) / 16.4 * 0.02;
    radianX_last = 0.8 * (radianX_last + radian_temp) + (-radianX) * 0.2;
```

9. 使用一个简单的互补滤波器来融合角速度数据和倾角数据，以得到更稳定的倾角。

```c
    //互补计算y轴倾角
    radianY = atan2(ax1, az1);
    radianY = radianY * 180.0 / 3.1415926;
    radian_temp = (float)(gy1) / 16.4 * 0.01;
    radianY_last = 0.8 * (radianY_last + radian_temp) + (-radianY) * 0.2;
  }
}
```

- #### 运行动作组

1. 根据**action_num**的值从action数组中取出对应的动作组数据，然后按照指定的步骤执行动作并等待其完成。当所有动作都执行完毕后，重置相关变量以准备下一次的动作执行。

```c
void HW_ACTION_CTL::action_task(void){
```

2. 声明变量，**last_tick**变量，用于存储上次任务执行的时间戳；step变量表示当前的动作执行步骤，有三个步骤：0表示运行动作，1表示等待动作运行，其他值则会被重置为0。**num** 和 **delay_count**变量，用于在动作执行过程中进行计数。

```c
  static uint32_t last_tick = 0;
  static uint8_t step = 0;
  static uint8_t num = 0 , delay_count = 0;
```

3. 如果**action_num**的值在1到3之间（包括1和3），则进入动作组处理流程（**action_num**变量，表示当前要执行的动作组的编号）。

```c
  if(action_num != 0 && action_num <= action_count)
  {
```

4. 使用**millis()**函数获取当前的时间戳，并与**last_tick**进行比较。如果两次执行的时间间隔小于150毫秒，则直接返回，避免动作执行过于频繁。

```c
    // 间隔时间
    if (millis() - last_tick < 150) {
      return;
    }
    last_tick = millis();
```

case 0：表示需要执行动作。从action数组中取出当前动作组的当前动作（由num指定）的关节角度数据，并存储到**extended_func_angles**数组中。

如果当前动作的关节角度数据不全为0（即该动作还未执行完毕），则将step设置为1，表示接下来需要等待动作执行完成。

```c
if(action[action_num-1][num][0] != 0)
        {
          extended_func_angles[0] = action[action_num-1][num][1];
          extended_func_angles[1] = action[action_num-1][num][2];
          extended_func_angles[2] = action[action_num-1][num][3];
          extended_func_angles[3] = action[action_num-1][num][4];
          extended_func_angles[4] = action[action_num-1][num][5];
          extended_func_angles[5] = action[action_num-1][num][6];

          step = 1;
```

如果当前动作的关节角度数据全为0，则表示该动作组已执行完毕，将num重置为0，并将action_num重置为0，表示没有动作组需要执行。

```c
          step = 1;

        }else{ //若运行完毕
          num = 0;
          // 清空动作组变量
          action_num = 0;
          
        }
        break;
```

case 1：表示需要等待当前动作执行完成。

使用**delay_count**进行简单的延时，这里每次增加1，当**delay_count**大于2时，将num增加1（表示下一个动作），重置delay_count为0，并将step重置为0，表示接下来可以执行新的动作。

```c
      case 1: //等待动作运行
        delay_count++;
        if(delay_count > 2)
        {
          num++;
          delay_count = 0;
          step = 0;
        }
        break;
```

如果step的值不是0或1，则将其重置为0。

```c
      default:
        step = 0;
        break;
    }
  }
}
```

- #### 舵机控制

如果想要让舵机逐渐向目标位置靠近，则控制任务函数中需要调用到**servo_angles\[i\] = servo_angles\[i\] \* 0.90 + extended_func_angles\[i\] \* 0.1**这行代码。

这使得舵机在每次都会以实际值的90%+期望值的10%来移动，从而使实际值逐渐接近期望值，当等于期望值时，手掌就能够停止移动。

```c
//舵机控制任务
void servo_control(void) {
  static uint32_t last_tick = 0;
  if (millis() - last_tick < 20) {
    return;
  }
  last_tick = millis();
  for (int i = 0; i < 6; ++i) {
    servo_angles[i] = servo_angles[i] * 0.90 + action_ctl.extended_func_angles[i] * 0.10;
    servos[i].write(i == 0 || i == 5 ? 180 - servo_angles[i] : servo_angles[i]);
  }
}
```

- #### 蜂鸣器控制

控制蜂鸣器按照指定的节奏和音调数组播放旋律。

```c
// 蜂鸣器任务
void tune_task(void) {
```

1. 声明变量，**l_tune_beat**变量，用于存储上一次播放音调的间隔时间（以毫秒为单位）；**last_tick**变量，用于存储上一次函数执行的时间戳。控制蜂鸣器按照指定的节奏和音调数组播放旋律。

```c
  static uint32_t l_tune_beat = 0;
  static uint32_t last_tick = 0;
```

2. 判断是否需要播放音调，使用 **millis()** 函数获取当前的时间戳，并与 **last_tick** 进行比较。如果当前时间与上一次播放音调的时间间隔小于 **l_tune_beat**，并且 tune_beat 的值没有变化（即 **tune_beat** 与 **l_tune_beat** 相等），则函数直接返回，不执行任何操作。这是为了防止在相同的间隔时间内重复播放相同的音调。

```c
  if (millis() - last_tick < l_tune_beat && tune_beat == l_tune_beat) {
    return;
  }
```

3. 更新变量，将 **tune_beat** 的值赋给 **l_tune_beat**；更新 last_tick 为当前时间戳。

```c
  l_tune_beat = tune_beat;
  last_tick = millis();
```

4. 如果 **tune_num** 大于 0，表示还有剩余的音调需要播放，使用 **tone()** 函数在 **buzzerPin** 引脚上播放当前音调。

```c
  if (tune_num > 0) {
    tune_num -= 1;
    tone(buzzerPin, *tune++);
```

5. 如果 **tune_num** 不大于 0，表示所有的音调都已经播放完毕；使用 **noTone()** 函数停止蜂鸣器发声；重置 **tune_beat** 和 **l_tune_beat** 为 10（可能是默认的播放间隔），准备下一次播放旋律。

```c
  } else {
    noTone(buzzerPin);
    tune_beat = 10;
    l_tune_beat = 10;
  }
}
```

- #### 蜂鸣器发声控制

指定要播放的音调数组、播放音调的间隔以及要播放的音调数量。

```c
// 蜂鸣器鸣响函数
void play_tune(uint16_t *p, uint32_t beat, uint16_t len) {
  tune = p;
  tune_beat = beat;
  tune_num = len;
}
```

**tune = p**;将变量 **tune**（是一个指向音调数组的指针）设置为传入的参数 **p** 的值。这样，**tune** 就指向了用户提供的音调数组。

**tune_beat = beat**;将变量 **tune_beat**（表示播放音调的间隔）设置为传入的参数 **beat** 的值。这决定了音调的播放节奏。

**tune_num = len**;将变量 **tune_num**（表示要播放的音调的数量）设置为传入的参数 **len** 的值。这确定了播放列表的长度。

