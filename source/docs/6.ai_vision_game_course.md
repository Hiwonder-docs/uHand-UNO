# AI视觉玩法课程

<p id="ESP32-Cam-introduction"></p>

## 6.1 ESP32-Cam介绍及安装

### 1.ESP32-Cam说明

- #### 硬件介绍

ESP32-CAM是一款基于ESP32微控制器的小尺寸摄像头模组。该模块可以作为最小系统独立工作，尺寸仅为27\*40.5\*4.5mm，深度睡眠电流最低达到6mA。

ESP32-CAM采用DIP封装，直接插上底板即可使用，为客户提供高可靠性的连接方式，方便应用于各种物联网硬件终端场合。

其硬件结构如下图所示：

<p align="center">
<img src="../_static/media/uhand uno-6/6-1.png" alt="6-1" style="width:700px"/>
</p>



- #### 工作原理

通过内置的摄像头模块进行图像采集，利用ESP32微控制器对图像数据进行处理，并通过Wi-Fi模块进行无线传输或保存到microSD卡中，同时支持多种通信协议和低功耗特性，广泛应用于各种物联网应用场景中。

### 2.接口说明及安装方法

- #### 摄像头载板接口说明

<p align="center">
<img src="../_static/media/uhand uno-6/6-2.png" alt="6-2" style="width:700px"/>
</p>

| 接口名称 | 接口说明 |
| :-: | :-: |
| TypeC串口 | 串口通信、固件烧录 |
| 排母  | 连接ESP32-Cam模块 |
| 复位按钮 | 按下即可重启程序 |
| IIC接口 | 二次开发接口，与主控进行连接 |
| 用户按钮 | 用户自定义扩展开发 |

- #### 摄像头的安装与连接

1. 将ESP32-Cam的排针，与摄像头载板的排母一一对齐进行安装。


<p align="center">
<img src="../_static/media/uhand uno-6/6-3.png" alt="6-3" style="width:700px"/>
</p>

2. 使用Type-C数据线连接摄像头与电脑。

<p align="center">
<img src="../_static/media/uhand uno-6/6-4.png" alt="6-4" style="width:700px"/>
</p>

3. 根据“**[3 图像回传](#Image-return)**”中的教程查看摄像头的回传画面。

<p align="center">
<img src="../_static/media/uhand uno-6/6-5.png" alt="6-5" style="width:700px"/>
</p>

### 3.注意事项

1. 请保证模块输入电源至少5V 2A,否则图片会有几率出现水纹。
2. 出厂已烧录图像回传固件，如需其他功能要重新烧录程序，请根据“**1.教程资料\\6.AI视觉玩法课程**”下的玩法下载。

### 4.参数说明

- #### ESP32-Cam引脚说明

<p align="center">
<img src="../_static/media/uhand uno-6/6-6.png" alt="6-6" style="width:700px"/>
</p>

<p align="center">
<img src="../_static/media/uhand uno-6/6-7.png" alt="6-7" style="width:700px"/>
</p>


- #### ESP32-Cam规格参数

| 参数  | 描述  |
| :-: | :-: |
| 工作电压 | 5V 2A稳压源供电 |
| 处理器 | Tensilica LX6 双核处理器 |
| 主频  | 80 MHz（正常工作速度），最高可达 240 MHz |
| SRAM | 520 KB |
| 外置存储器 | 最大支持 8 MB PSRAM |
| Flash | 最大支持 16 MB 片外 SPI Flash |
| WiFi协议 | 802.11 b/g/n/d/e/i/k/r，速度高达 150 Mbps |
| WiFi频率范围 | 2.4 ~ 2.5 GHz |
| 蓝牙协议 | 支持蓝牙 v4.2，包含传统蓝牙 (BR/EDR) 和低功耗蓝牙 (BLE) |
| 摄像头 | 支持 OV2640 和 OV7670 摄像头，内置闪光灯 |
| 图片上传 | 支持通过 Wi-Fi 上传图片 |
| 存储  | 支持 microSD 卡 |
| 接口  | GPIO/ADC/ DAC/ SPI/ I2C/PWM/ UART |
| 电源电流 | 深度睡眠模式下最低 6mA |
| 工作模式 | STA/AP/STA+AP |
| 二次开发 | 支持  |
| 尺寸  | 27 × 40.5 × 4.5 mm |

:::{Note}

产品规格参数为理论值，仅供参考，请以实际效果为准。

关于产品详细参数可前往“4.拓展学习资料\\5.ESP32-Cam摄像头模块资料”路径下查看产品规格书。

:::


## 6.2 ESP32-Cam库文件介绍

本节对ESP32-Cam模块的驱动库进行分析，这个库是用来获取ESP32-Cam模块识别到的人脸数据或颜色数据、控制补光灯亮度的，该库包含**hw_esp32cam_ctl.h和hw_esp32cam_ctl.cpp**这2个文件。

### 1.准备工作及注意事项

1. 在“**AI视觉玩法课程**”打开任意程序，这里我们以“4. 颜色分拣”为例。

<p align="center">
<img src="../_static/media/uhand uno-6/6-8.png" alt="6-8" style="width:700px"/>
</p>

2. 在打开的程序中，选择“**hw_esp32cam_ctl.cpp**”。

<p align="center">
<img src="../_static/media/uhand uno-6/6-9.png" alt="6-9" style="width:700px"/>
</p>

### 2.程序简要分析

1. 初始化IIC通信的函数：**begin()**。

```c
void HW_ESP32Cam::begin(void)
{
  Wire.begin();
}
```

2. 向esp32Cam发送多个字节：**wireWriteDataArray()**。

```c
//写多个字节
static bool wireWriteDataArray(uint8_t addr, uint8_t reg,uint8_t *val,unsigned int len)
{
    unsigned int i;

    Wire.beginTransmission(addr);
    Wire.write(reg);
    for(i = 0; i < len; i++) 
    {
        Wire.write(val[i]);
    }
    if( Wire.endTransmission() != 0 ) 
    {
        return false;
    }
    return true;
}
```

参数及含义：

- **addr**：esp32Cam设备地址（0x52）

- **reg**：向esp32Cam写入的目标内存地址

- <b>*val</b>:需要发送的数据地址

- **len**：需要发送的字长

arduino主设备首先通过IIC发送设备地址，再向esp32Cam发送目标内存的地址，再根据字长按字节发送数据。之后通过endTransmission()检测数据是否发送成功，若返回值为0，表示数据发送成功，否则表示发送失败。

3. 向esp32Cam发送1个字节：**wireWriteByte()**

```c
static bool WireWriteByte(uint8_t val)
{
    Wire.beginTransmission(ESP32CAM_ADDR);
    Wire.write(val);
    if( Wire.endTransmission() != 0 ) {
        return false;
    }
    return true;
}
```

参数及含义：

- **val**：发送的数据内容

arduino主设备直接向esp32Cam发送设备地址，再将1字节的数据内容发送给esp32Cam。之后通过**endTransmission()**检测数据是否发送成功，若返回值为0，表示数据发送成功，否则表示发送失败。

4. 从esp32Cam读取多字节的数据：wireReadDataArray()

```c
static int WireReadDataArray(uint8_t reg, uint8_t *val, unsigned int len)
{
    unsigned char i = 0;
    
    /* Indicate which register we want to read from */
    if (!WireWriteByte(reg)) {
        return -1;
    }
    
    /* Read block data */
    Wire.requestFrom(ESP32CAM_ADDR, len);
    while (Wire.available()) {
        if (i >= len) {
            return -1;
        }
        val[i] = Wire.read();
        i++;
    }   
    return i;
}
```

参数及含义：

- **reg**：esp32Cam中需要读取的数据地址
- <b>*val</b>：arduino主设备中用于存放数据的地址
- **len**：需要读取的字长

arduino主设备首先向esp32Cam发送需要读取的数据地址，若无应答返回-1，表示esp32Cam建立连接失败。之后，向esp32Cam设备发送字长，通过while循环以及i的变量按字节读取数据，并存放在val\[\]数组中。若读取过程中，实际读取的字长超过了需要读取的字长，则返回-1，表示读取失败。最后，在读取成功后返回i，即实际读取到的字长（**<font color="red">i可能小于或等于len</font>**）

5. 读取esp32Cam检测人脸的结果：faceDetect()

```c
//读取ESP32Cam检测人脸
bool HW_ESP32Cam::faceDetect(void)
{
  uint8_t face_info[4];
  Serial.print("face ");
  int num = WireReadDataArray(0x01,face_info,4);
  if((num == 4) && (face_info[2] > 0)) 
  //Received the x, y, w, h values of the recognized face
  {
      Serial.println(" 1");
      return true;
  }
  Serial.println(" 0");
  return false;
}
```

定义**face_info\[4\]**数组用于存放数据，通过**wireReadDataArray()**函数，从0x01的地址，读取四个字节存放在**face_info\[4\]**数组中。其中，各元素含义如下：

- **face_info\[0\]**：x（识别到人脸区域左上角的x坐标值）

- **face_info\[1\]**：y（识别到人脸区域左上角的y坐标值）

- **face_info\[2\]**：w（识别到人脸区域的宽度）

- **face_info\[3\]**：h（识别到人脸区域的高度）

通过num变量接收数据的长度，如果为4且face_info\[2\]（即w的值）为大于0，则表示识别到人脸，则返回true，否则返回false。

6. 读取esp32Cam识别颜色的结果：**colorDetect()**

```c
//读取ESp32Cam识别颜色，返回颜色代号
int HW_ESP32Cam::colorDetect(void)
{
  uint8_t color_info[2][4];
  int num = WireReadDataArray(0x00,color_info[0],4);
  if((num == 4) && (color_info[0][2] > 0)) 
  //接受识别到的颜色的x,y,w,h值
  {
      return 1;
  }
  num = WireReadDataArray(0x01,color_info[1],4);
  if(num == 4)
  {
    if(color_info[1][2] > 0) 
    //若w值大于0，则识别到颜色1
    {
      return 2;
    }
  }
  return 0;
}
```

定义color_info\[2\]\[4\]二维数组用于存放数据，各元素含义如下：

- **color_info\[\*\]\[0\]**：x（识别到颜色区域左上角的x坐标值）

- **color_info\[\*\]\[1\]**：y（识别到颜色区域左上角的y坐标值）

- **color_info\[\*\]\[2\]**：w（识别到颜色区域的宽度）

- **color_info\[\*\]\[3\]**：h（识别到颜色区域的高度）

以上，若\*为0表示识别颜色1，若\*为1表示识别颜色2。

通过**wireReadDataArray()**函数，从0x00的地址，读取四个字节数据存放在color_info\[0\]\[4\]数组中，表示识别到颜色1的参数信息。根据num接收的数据长度以及color_info\[0\]\[2\]的值（即识别到颜色1的区域宽度）判断是否识别到颜色1，若num=4且color_info\[0\]\[2\]>0则识别到颜色1，识别到则返回1。

否则按照以上步骤，从0x01的地址读取数据存放在color_info\[1\]\[4\]数组中，再判断是否读取到颜色2识别到则返回2。

若以上都没有结果，则返回0。

7. 读取esp32Cam识别颜色的位置：**color_position()**

```c
//读取ESP32Cam识别颜色的位置，读取成功返回true和位置数据
bool HW_ESP32Cam::color_position(uint16_t *color_info)
{
  int num = WireReadDataArray(0x01,(uint8_t*)color_info,8);
  if((num == 8) && (color_info[2] > 0)) 
  //接受识别到的颜色的x,y,w,h值
  {
    return true;
  }
  return false;
}
```

参数及含义如下：

- **color_info** ：存放接收到数据的地址

通过**wireReadDataArray()**函数，从0x01的地址，读取8个字节数据存放在color_info所指向的地址中。根据num接收的数据长度以及color_info\[2\]的值（即识别到颜色区域的宽度）判断是否识别到颜色，若num=8且color_info\[2\]>0则识别到颜色，识别到则返回true，否则返回false。

8. 控制esp32Cam的补光灯亮度：**set_led()**

```c
void HW_ESP32Cam::set_led(uint8_t lightness)
{
  lightness = lightness < 0 ? 0 : lightness;
  lightness = lightness > 255 ? 255 : lightness;
  wireWriteDataArray(ESP32CAM_ADDR , 0x11 , &lightness , 1);
}
```

参数及含义如下：

lightness：补光灯亮度（0~255）

首先识别传入参数是否有限，主要通过判断参数的值是否在0-255范围内， 若小于0，则使其为0，若超出255，则使其为255。以此，保证传入参数的有效性。最后，通过**wireWriteDataArray()**函数将**lightness**参数值，发送给esp32Cam的0x11的地址。

<p id="Image-return"></p>

## 6.3 图像回传

本节通过连接ESP32-Cam产生的热点，登录固定网址查看摄像头实时回传画面。

:::{Note}

注意：若无法使用图像回传功能或下载了其他玩法的固件，需要重新烧录图像回传固件才可以使用图像回传功能。

固件下载可查看本文档中的 [4.图像回传固件烧录（选看）](#_4.图像回传固件烧录（选看）)

:::

### 1.连接ESP32-Cam摄像头

- #### 连接模式介绍

ESP32-Cam摄像头有下列两种网络模式：

- AP直连模式：开发板能够开启热点被手机连接上。（但不能联通外部网络）

- STA局域网模式：开发板能够主动去连接指定的热点/Wi-Fi。（可联通外部网络）

使用直连模式操作更加简单方便，这里建议用户先学习直连模式的配置方法进行相应功能的体验，局域网模式可根据需求来选看。

另外用户无论是选择AP直连还是STA局域网模式，玩法功能都一致。

- #### 直连模式连接（必看）

1. 确认摄像头已连接至扩展板的IIC接口中，将机械手掌开机。

<p align="center">
<img src="../_static/media/uhand uno-6/6-10.png" alt="6-10" style="width:700px"/>
</p>

2. 此时摄像头会产生一个名称为“**HW_ESP32Cam**”的热点，点击连接即可。

<p align="center">
<img src="../_static/media/uhand uno-6/6-11.png" alt="6-11" style="width:500px"/>
</p>

<p align="center">
<img src="../_static/media/uhand uno-6/6-12.png" alt="6-12" style="width:500px"/>
</p>

3. 连接完成后，在浏览器中输入地址“**192.168.5.1**”点击搜索，即可进入到摄像头回传界面。

<p align="center">
<img src="../_static/media/uhand uno-6/6-13.png" alt="6-13" style="width:700px"/>
</p>

- #### 局域网模式连接（选看）

1. 将手机热点打开，设置热点名称为“**HiwonderESP**”，密码为“**hiwonder**”（**<font color="red">注意：热点名称和密码与本文保持一致，否则会连接不上</font>**）。

<p align="center">
<img src="../_static/media/uhand uno-6/6-14.png" alt="6-14" style="width:400px"/>
</p>

<p align="center">
<img src="../_static/media/uhand uno-6/6-15.png" alt="6-15" style="width:400px"/>
</p>

2. 确认摄像头已连接至扩展板的IIC接口中，将机械手掌开机，稍等片刻，摄像头就会自动连接手机热点。

<p align="center">
<img src="../_static/media/uhand uno-6/6-10.png" alt="6-10" style="width:700px"/>
</p>

3. 网络连接成功后，使用Type数据线连接摄像头与电脑。

<p align="center">
<img src="../_static/media/uhand uno-6/6-4.png" alt="6-4" style="width:700px"/>
</p>

4. 打开“**2.软件工具&程序合辑\\5.串口调试助手工具**”路径下的友善串口调试助手工具。

<p align="center">
<img src="../_static/media/uhand uno-6/6-17.png" alt="6-17" style="width:900px"/>
</p>

5. 选择端口，此处以COM3为例（**<font color="red">端口号不唯一，如果是COM1请不要选择，它是系统通信端口</font>**），将波特率设置为“**115200**”。

<p align="center">
<img src="../_static/media/uhand uno-6/6-18.png" alt="6-18" style="width:700px"/>
</p>

6. 点击页面左上方的<img src="../_static/media/uhand uno-6/6-19.png" alt="6-19" style="width: 30px; margin: 0 5px;"/>按钮打开串口通信，按下ESP32摄像头载板上的“**RST**”按键，往下滑到最后一行，即可看到摄像头的IP地址“**192.168.197.226**”（**<font color="red">IP地址不唯一，用户需以实际为准</font>**）。

<p align="center">
<img src="../_static/media/uhand uno-6/6-20.png" alt="6-20" style="width:700px"/>
</p>

7. 此时可断开Type-C数据线，将电脑也连接至摄像头同一热点下。

<p align="center">
<img src="../_static/media/uhand uno-6/6-22.png" alt="6-22" style="width:700px"/>
</p>

8. 在浏览器搜索界面输入摄像头的IP地址“**192.168.197.226**”即可查看回传界面。

<p align="center">
<img src="../_static/media/uhand uno-6/6-23.png" alt="6-23" style="width:700px"/>
</p>

### 2.开启图像回传

连接完成后，点击界面上的“**Start Stream**”按钮即可开启图像回传。

<p align="center">
<img src="../_static/media/uhand uno-6/6-24.png" alt="6-24" style="width:700px"/>
</p>

<p align="center">
<img src="../_static/media/uhand uno-6/6-25.png" alt="6-25" style="width:700px"/>
</p>

### 3.界面介绍

此界面可分为两个部分，①界面设置区域，②画面回传区域。

<p align="center">
<img src="../_static/media/uhand uno-6/6-26.png" alt="6-26" style="width:700px"/>
</p>

界面设置区域的常用按钮介绍说明如下图及表所示：  

<p align="center">
<img src="../_static/media/uhand uno-6/6-27.png" alt="6-27" style="width:950px"/>
</p>

| 编号  | 按钮名称 | 按钮功能 |
| :-: | :-: | :-: |
| 1   | Resolution | 可选择画面显示的分辨率，分辨率越小画面越流畅。 |
| 2   | H-Mirror | 垂直翻转画面 |
| 3   | V-Flip | 水平翻转画面 |
| 4   | Face Detection | 点击后，可进行人脸识别 |
| 5   | Face Recognition | 同时选中Face Detection和Face Recognition按钮待识别到人脸后点击“Get Still”按键即可学习特定人脸 |
| 6   | Get Still | 点击可学习特定人脸 |
| 7   | Stop Stream | 关闭图像回传画面 |
| 8   | Save | 保存图像 |

可参考“**4.拓展学习资料\\5.ESP32-Cam摄像头模块资料**”查看ESP32-Cam更详细的使用说明教程。

### 4.图像回传固件烧录（选看）

1. 根据“**[1. ESP32-Cam介绍及安装](#ESP32-Cam-introduction)**”将ESP32-Cam安装并连接至机械手掌的IIC接口上。

<p align="center">
<img src="../_static/media/uhand uno-6/6-10.png" alt="6-10" style="width:700px"/>
</p>

2. 将Type-C数据线一端连接ESP32-Cam另一端连接电脑的USB接口。

<p align="center">
<img src="../_static/media/uhand uno-6/6-4.png" alt="6-4" style="width:700px"/>
</p>

3. 双击并打开“**2.软件工具&源码程序\\4.固件烧录工具**” 路径下的 “**flash_download_tools_v3.6.5.exe**” 文件。

<p align="center">
<img src="../_static/media/uhand uno-6/6-28.png" alt="6-28" style="width:950px"/>
</p>

4. 稍等片刻，在打开的界面中，选择“**ESP32 DownloadTool**”。

<p align="center">
<img src="../_static/media/uhand uno-6/6-29.png" alt="6-29" style="width:400px"/>
</p>

5. 在烧录界面中，先再点击“<img src="../_static/media/uhand uno-6/6-30.png" alt="6-30" style="width:40px"/>”选择固件(解压“camera_web_server_V1.1.zip”文件，找到“**ESP32-Cam图像回传固件\\HW_ESP32cam_web_server_0.bin**”)再根据下图所框内容选择如下配置。**（<font color="red">注意：如果图传画面出现颠倒，请烧录HW_ESP32cam_web_server_1.bin</font>）**

<p align="center">
<img src="../_static/media/uhand uno-6/6-31.png" alt="6-31" style="width:500px"/>
</p>

<p align="center">
<img src="../_static/media/uhand uno-6/6-32.png" alt="6-32" style="width:500px"/>
</p>

6. 选择端口号（端口号以实际情况为准，切勿选择COM1，否则会烧录不成功）。

<p align="center">
<img src="../_static/media/uhand uno-6/6-33.png" alt="6-33" style="width:500px"/>
</p>

7. 先点击“**ERASE**”，对底层固件进行擦除（**一定要进行此操作**），再点击“**START**”，开始烧录。

<p align="center">
<img src="../_static/media/uhand uno-6/6-34.png" alt="6-34" style="width:500px"/>
</p>

8. 稍等片刻，会出现完成的提示。

<p align="center">
<img src="../_static/media/uhand uno-6/6-35.png" alt="6-35" style="width:500px"/>
</p>

9. 烧录完成后断开Type-C数据线即可。

## 6.4 颜色分拣

本节讲解uHand UNO通过搭载的ESP32-Cam，实现识别红、蓝小球，并将小球抓取放置到对应位置的功能实现。

### 1.实现流程图

<p align="center">
<img src="../_static/media/uhand uno-6/6-36.png" alt="6-36" style="width:700px"/>
</p>

### 2.ESP32-Cam开发板模块

<p align="center">
<img src="../_static/media/uhand uno-6/6-37.png" alt="6-37" style="width:400px"/>
</p>

这是一款集成了ESP32芯片和摄像头模块的开发板，模块插入载板后，采用 IIC 通信接口，能通过 IIC通信进行读取颜色、人脸数据。

- #### 模块工作原理

ESP32-CAM板载了摄像头模块，通过串行接口将采集的图像数据传输给ESP32芯片，后者可处理图像并通过IIC通信传输至其他设备。

- #### 模块原理图

模块通过ESP32芯片控制同时负责整个系统的控制和通讯功能，通过摄像头采集图像数据，经过处理和分析，最终执行相应操作。

<p align="center">
<img src="../_static/media/uhand uno-6/6-38.png" alt="6-38" style="width:700px"/>
</p>

- **供电电压：5V**
- **功耗：6mA-180mA**
- **工作温度：-20℃~70℃**


- #### 传感器接线

将ESP32-Cam的排针接到摄像头载板的排母上，再使用4PIN线将摄像头载板与扩展板上的任意一个IIC接口进行连接。

<p align="center">
<img src="../_static/media/uhand uno-6/6-10.png" alt="6-10" style="width:700px"/>
</p>

### 3.程序下载

:::{Note}

1. 下载程序前需先将蓝牙模块取下，否则会因串口冲突导致程序下载失败。

2. 接入Type-B下载线时请将电池盒开关拨到“OFF”挡，避免下载线误碰到扩展板的电源引脚，造成短路。

:::

- #### Arduino UNO程序下载

1. 找到并打开本节同目录下的 “**02 程序文件\\02 uHand UNO颜色分拣例程\\uhand_colors_clamp_esp32cam\\uhand_colors_clamp_esp32cam.ino**” 程序文件。

<p align="center">
<img src="../_static/media/uhand uno-6/6-39.png" alt="6-39" style="width:700px"/>
</p>

2. 将Arduino通过UNO数据线（Type-B）连接至电脑。

<p align="center">
<img src="../_static/media/uhand uno-6/6-40.png" alt="6-40" style="width:700px"/>
</p>

3. 点击“**选择开发板**”选项，软件会自动检测当前Arduino串口，点击进行连接。

<p align="center">
<img src="../_static/media/uhand uno-6/6-41.png" alt="6-41" style="width:700px"/>
</p>

4. 点击<img src="../_static/media/uhand uno-6/6-42.png" alt="6-42" style="width:30px"/>，将程序下载至Arduino中，等待下载完成即可。

<p align="center">
<img src="../_static/media/uhand uno-6/6-43.png" alt="6-43" style="width:700px"/>
</p>

<p align="center">
<img src="../_static/media/uhand uno-6/6-44.png" alt="6-44" style="width:700px"/>
</p>

- #### ESP32-Cam程序下载

1. 参照“**1.教程资料\\4.二次开发课前准备\\4.1 Arduino开发环境搭建\\02 Arduino IDE使用说明->3.ESP32-Cam环境配置**”搭建好ESP32开发板环境。
2. 找到并打开本节同目录下的“**ESP32Cam_color_clamp\\ESP32Cam_color_clamp.ino**”程序文件。

<p align="center">
<img src="../_static/media/uhand uno-6/6-45.png" alt="6-45" style="width:700px"/>
</p>

3. 将ESP32-Cam通过USB数据线（Type-C）连接至电脑。

<p align="center">
<img src="../_static/media/uhand uno-6/6-4.png" alt="6-4" style="width:700px"/>
</p>

4. 点击“**选择开发板**”选项，在选择其他开发板和端口选项中，选择**AI Thinker ESP-CAM**，并选择对应端口。

<p align="center">
<img src="../_static/media/uhand uno-6/6-46.png" alt="6-46" style="width:700px"/>
</p>

5. 点击<img src="../_static/media/uhand uno-6/6-42.png" alt="6-42" style="width:30px"/>，将程序下载至ESP32Cam中，等待下载完成即可。

<p align="center">
<img src="../_static/media/uhand uno-6/6-47.png" alt="6-47" style="width:700px"/>
</p>

<p align="center">
<img src="../_static/media/uhand uno-6/6-44.png" alt="6-44" style="width:700px"/>
</p>

### 4.实现效果

1. 打开机械手掌电源后，机械手掌云台回到中位，五指张开，同时扩展板上的RGB灯亮绿色。

<p align="center">
<img src="../_static/media/uhand uno-6/6-48.png" alt="6-48" style="width:500px"/>
</p>

2. 当识别到蓝色小球时，RGB亮蓝灯，手掌将小球抓取，放置在右边。

<p align="center">
<img src="../_static/media/uhand uno-6/6-49.png" alt="6-49" style="width:500px"/>
</p>

3. 当识别到红色小球时，RGB亮红灯，手掌将小球抓取，放置在左边。

<p align="center">
<img src="../_static/media/uhand uno-6/6-50.png" alt="6-50" style="width:500px"/>
</p>

### 5.程序简要分析

本玩法程序名为“**uhand_colors_clamp_esp32cam.ino**”，关于程序的实现逻辑可参考下面的流程图：

<p align="center">
<img src="../_static/media/uhand uno-6/6-51.png" alt="6-51" style="width:700px"/>
</p>

- #### 导入库文件

1. 导入玩法所需的RGB控制库、舵机控制库、ESP32Cam的通信库、蜂鸣器的音调库文件。

```c
#include <FastLED.h> //导入LED库
#include <Servo.h> //导入舵机库
#include "hw_esp32cam_ctl.h" //导入ESP32Cam通讯库
#include "tone.h" //音调库
```

2. 定义音调常量和颜色常量。

```c
const static uint16_t DOC5[] = { TONE_C5 };
const static uint16_t DOC6[] = { TONE_C6 };

#define COLOR_1   1
#define COLOR_2   2
```

- #### 定义引脚及创建对象

1. 首先定义了用于连接硬件的Arduino引脚，主要是六个舵机引脚、一个蜂鸣器引脚和一个RGB灯引脚。

```c
/* 引脚定义 */
const static uint8_t servoPins[6] = { 7, 6, 5, 4, 3, 2 };
const static uint8_t buzzerPin = 11;
const static uint8_t rgbPin = 13;
```

2. 然后定义了用于控制RGB灯、ESP32Cam通讯、舵机的变量。**extended_func_angles**数组用于存储每个舵机的期望角度，而**servo_angles**数组用于存储舵机的实际角度，范围是0~180，这里是设置了手掌初始位置为张开；

```c
//RGB灯控制对象
static CRGB rgbs[1];
//ESP32Cam通讯对象
HW_ESP32Cam hw_cam;
//舵机控制对象
Servo servos[6];
// 舵机角度相关变量
static uint8_t extended_func_angles[6] = { 80, 100, 100, 80, 70, 95 }; /* 二次开发例程使用的角度数值 */
static uint8_t servo_angles[6] = { 80, 100, 100, 80, 70, 95 };  /* 舵机实际控制的角度数值 */
```

对于期望值与实际值，可以看到loop主函数中调用的**servo_control**函数。

如果想要让舵机逐渐向目标位置靠近，则控制任务函数中需要调用到**servo_angles\[i\] = servo_angles\[i\] \* 0.85 + extended_func_angles\[i\] \* 0.15**这行代码。

这使得舵机每次都会以实际值的85%+期望值的15%来移动，从而实际值逐渐接近期望值，当等于期望值时，手掌就能够停止移动。

```c
//舵机控制任务
void servo_control(void) {
  static uint32_t last_tick = 0;
  if (millis() - last_tick < 40) {
    return;
  }
  last_tick = millis();
  for (int i = 0; i < 6; ++i) {
    servo_angles[i] = servo_angles[i] * 0.85 + extended_func_angles[i] * 0.15;
    servos[i].write(i == 0 || i == 5 ? 180 - servo_angles[i] : servo_angles[i]);
  }
}
```

3. 接着定义了用于控制蜂鸣器的变量，并声明任务函数，用于执行不同的控制任务。**servo_contro**l函数用于控制舵机；**play_tune**用于控制蜂鸣器鸣响；**tune_task**函数用于执行蜂鸣器任务，**espcam_task**函数用于处理与ESP32-CAM相关的通信。

```c
// 蜂鸣器相关变量
static uint16_t tune_num = 0;
static uint32_t tune_beat = 10;
static uint16_t *tune;

static void servo_control(void); /* 舵机控制 */
void play_tune(uint16_t *p, uint32_t beat, uint16_t len); /* 蜂鸣器控制接口 */
void tune_task(void); /* 蜂鸣器控制任务 */
void espcam_task(void); /* esp32cam通讯任务 */
```

- #### 初始化设置

1. 在**setup()** 函数中，主要是对相关的硬件设备进行初始化。首先是串口，将其通信的波特率设置为115200以及读取数据超时时间为500ms。

```c
void setup() {
  Serial.begin(115200);
  // 设置串行端口读取数据的超时时间
  Serial.setTimeout(500);
```

2. 绑定舵机IO口，方便通过引脚对其进行控制。

```c
  // 绑定舵机IO口
  for (int i = 0; i < 6; ++i) {
    servos[i].attach(servoPins[i],500,2500);
  }
```

3. 初始化与ESP32-CAM的通信接口并设置ESP32-CAM的补光灯亮度为10（在0到255的范围内）。

```c
  hw_cam.begin(); //初始化与ESP32Cam通讯接口
  hw_cam.set_led(10); // 控制ESP32Cam补光灯亮度 [亮度值(0~255)]
```

4. 使用**FastLED**库初始化扩展板上的RGB灯，并连接到rgbPin引脚。通过**rgbs\[0\] = CRGB(0, 0, 100)** 设置颜色为蓝色，使用FastLED.show函数显示设置的颜色。

```c
  //RGB灯初始化并控制
  FastLED.addLeds<WS2812, rgbPin, GRB>(rgbs, 1);
  rgbs[0] = CRGB(0, 255, 0);
  FastLED.show();
```

5. 设置蜂鸣器的引脚为输出模式，控制蜂鸣器短鸣一声后停止。

```c
  //蜂鸣器初始化并鸣响一声
  pinMode(buzzerPin, OUTPUT);
  tone(buzzerPin, 1000);
  delay(100);
  noTone(buzzerPin);
```

6. 通过串口输出“**Start**”字符串，表明传感器已经做好准备，并开始传输数据了。

```c
  delay(2000);
  Serial.println("start");
}
```

- #### 循环调用子函数

初始化完成后，进入loop主函数，依次循环调用“**espcam_task**”函数，检测颜色识别，执行抓取放置的操作；调用“**tune_task**”函数，执行蜂鸣器任务；调用“**servo_control**”函数，控制舵机。

```c
void loop() {
  // esp32cam通讯任务
  espcam_task();
  // 蜂鸣器鸣响任务
  tune_task();
  // 舵机控制
  servo_control();
}
```

- #### esp32cam通讯任务

1. 定义“**espcam_task**”函数，首先定义了6个变量。**last_tick**变量，用于记录上一次任务执行的时间点；posi变量定义云台舵机的角度；step变量，跟踪当前任务执行的阶段；**delay_count**变量设置演示的计量单位，color_state变量设置颜色的状态。color变量存放摄像头的检测结果。

```c
void espcam_task(void)
{
  static uint32_t last_tick = 0;
  static int posi = 90;
  static uint8_t step = 0;
  static uint8_t delay_count = 0;
  static uint8_t color_state = 0;
  int color = 0;
```

2. **last_tick**变量结合**millis()** 作延时操作，具体的通过**millis()**函数获取到当前程序运行的时间，与**last_tick**变量作差，如果差值小于100，则跳出该函数；如果大于或等于100，则意味着已经延时了100ms，接着再将当前的时间赋值给last_tick变量，用作下一次的延时操作。

```c
  if (millis() - last_tick < 100) {
    return;
  }
  last_tick = millis();
```

3. 根据检测到的颜色执行对应的任务，如控制RGB LED、蜂鸣器以及舵机的角度，以下是对这个switch代码段的分析：

- case 0：使用**hw_cam.colorDetect()**检测颜色，若检测到蓝色，则让RGB亮蓝灯，蜂鸣器发声进入下一个状态；检测到红色与此同理。

```c
  switch(step)
  {
    case 0:
      color = hw_cam.colorDetect(); //获取颜色
      if(color == COLOR_1)
      {
        rgbs[0].r = 0;
        rgbs[0].g = 0;
        rgbs[0].b = 250;
        FastLED.show();
        play_tune(DOC6, 300u, 1u);
        step++;
      }else if(color == COLOR_2)
      {
        rgbs[0].r = 250;     
        rgbs[0].g = 0;
        rgbs[0].b = 0;
        FastLED.show();
        play_tune(DOC6, 300u, 1u);
        step++;
```

若未检测到目标颜色则关闭RGB灯。

```c
      }else{
        rgbs[0].r = 0;
        rgbs[0].g = 0;
        rgbs[0].b = 0;
        FastLED.show();
      }
```

更新**color_state**变量以存储检测到的颜色。

```c
      color_state = color;
      break;
```

- case 1：等待一段时间后再进入下一个状态，给摄像头足够的时间完成颜色检测。

```c
    case 1:  //等待
      delay_count++;
      if(delay_count > 10)
      {
        step++;
        delay_count = 0;
      }
      break;
```

- case 2：抓取小球,将**delay_count**设为0，，转移到转移到下一个状态。

```c
    case 2://抓取
      extended_func_angles[0] = 11;
      extended_func_angles[1] = 31;
      extended_func_angles[2] = 56;
      extended_func_angles[3] = 43;
      extended_func_angles[4] = 29;
      delay_count = 0;
      step++;
      break;
```

- case 3：等待一段时间后再进入下一个状态。

```c
    case 3: //等待
      delay_count++;
      if(delay_count > 5)
      {
        step++;
      }
      break;
```

- case 4：若识别到颜色1（蓝色），让云台舵机转动到180°位置，否则让云台转动到0°位置。

```c
    case 4: //转动
      if(color_state == COLOR_1) //COLOR_1转到180°
      {
        posi += 10;
        if(posi >= 180)
          posi = 180;
      }else{ //COLOR_2转到0°
        posi -= 10;
        if(posi <= 0)
          posi = 0;
      }
      extended_func_angles[5] = posi;
```

等待动作结束后，进入下一个状态，并重置delay_count。

```c
      //等待转动结束，并等待
      delay_count++;
      if(delay_count >= 25)
      {
        step++;
        delay_count = 0;
      }
      break;
```

- case 5：将小球放开，等待一段时间进入下一个状态。

```c
    case 5: //放开
      extended_func_angles[0] = 80;
      extended_func_angles[1] = 100;
      extended_func_angles[2] = 100;
      extended_func_angles[3] = 80;
      extended_func_angles[4] = 70;
      delay_count++;
      if(delay_count >= 10)
      {
        step++;
        delay_count = 0;
      }
      break;
```

- case 6：云台舵机回到95°位置。等待一段时间重置状态。


```c
    case 6: //回到中位
      if(color_state == COLOR_1) //COLOR_1 180°->90°
      { 
        posi -= 10;
        if(posi <= 90)
          posi = 90;
      }else{ //COLOR_2 0°->90°
        posi += 10;
        if(posi >= 90)
          posi = 90;
      }
      extended_func_angles[5] = posi;
      //等待转动结束，并等待
      delay_count++;
      if(delay_count >= 18)
      {
        step = 0;
        delay_count = 0;
      }
      break;
    default:
      step = 0;
      break;
  }
}
```

- #### 舵机控制

如果想要让舵机逐渐向目标位置靠近，则控制任务函数中需要调用到“**servo_angles\[i\] = servo_angles\[i\] \* 0.85 + extended_func_angles\[i\] \* 0.1**”这5行代码。

这使得舵机每次都会以实际值的85% + 期望值的15%来移动，从而实际值逐渐接近期望值，当等于期望值时，手掌就能够停止移动。

```c
//舵机控制任务
void servo_control(void) {
  static uint32_t last_tick = 0;
  if (millis() - last_tick < 40) {
    return;
  }
  last_tick = millis();
  for (int i = 0; i < 6; ++i) {
    servo_angles[i] = servo_angles[i] * 0.85 + extended_func_angles[i] * 0.15;
    servos[i].write(i == 0 || i == 5 ? 180 - servo_angles[i] : servo_angles[i]);
  }
}
```

- #### 蜂鸣器控制

控制蜂鸣器按照指定的节奏和音调数组播放旋律。

```c
// 蜂鸣器任务
void tune_task(void) {
```

1. 声明变量，l_tune_beat变量，用于存储上一次播放音调的间隔时间（以毫秒为单位）；last_tick变量，用于存储上一次函数执行的时间戳。控制蜂鸣器按照指定的节奏和音调数组播放旋律。

```c
  static uint32_t l_tune_beat = 0;
  static uint32_t last_tick = 0;
```

2. 判断是否需要播放音调，使用 millis() 函数获取当前的时间戳，并与 last_tick 进行比较。如果当前时间与上一次播放音调的时间间隔小于 l_tune_beat，并且 tune_beat 的值没有变化（即 tune_beat 与 l_tune_beat 相等），则函数直接返回，不执行任何操作。这是为了防止在相同的间隔时间内重复播放相同的音调。

```c
  // 若未到定时时间 且 响的次数跟上一次的一样
  if (millis() - last_tick < l_tune_beat && tune_beat == l_tune_beat) {
    return;
  }
```

3. 更新变量，将 tune_beat 的值赋给 l_tune_beat；更新 last_tick 为当前时间戳。

```c
  l_tune_beat = tune_beat;
  last_tick = millis();
```

4. 如果 tune_num 大于 0，表示还有剩余的音调需要播放，使用 tone() 函数在 buzzerPin 引脚上播放当前音调。

```c
  if (tune_num > 0) {
    tune_num -= 1;
    tone(buzzerPin, *tune++);
```

5. 如果 tune_num 不大于 0，表示所有的音调都已经播放完毕；使用 noTone() 函数停止蜂鸣器发声；重置 tune_beat 和 l_tune_beat 为 10（可能是默认的播放间隔），准备下一次播放旋律。

```c
  } else {
    noTone(buzzerPin);
    tune_beat = 10;
    l_tune_beat = 10;
  }
}
```

- #### 蜂鸣器发声控制

指定要播放的音调数组、播放音调的间隔以及要播放的音调数量。

```c
// 蜂鸣器鸣响函数
void play_tune(uint16_t *p, uint32_t beat, uint16_t len) {
  tune = p;
  tune_beat = beat;
  tune_num = len;
}
```

tune = p;将变量 tune（是一个指向音调数组的指针）设置为传入的参数 p 的值。这样，tune 就指向了用户提供的音调数组。

tune_beat = beat;将变量 tune_beat（表示播放音调的间隔）设置为传入的参数 beat 的值。这决定了音调的播放节奏。

tune_num = len;将变量 tune_num（表示要播放的音调的数量）设置为传入的参数 len 的值。这确定了播放列表的长度。



## 6.5 颜色追踪

本节通过uHand UNO搭载ESP32-Cam，实现识别蓝小球，同时手掌跟随小球向左右方向转动。

### 1.实现流程图

<p align="center">
<img src="../_static/media/uhand uno-6/6-54.png" alt="6-54" style="width:700px"/>
</p>



### 2.实现效果

1. 打开机械手掌电源后，机械手掌云台回到中位，五指张开，同时扩展板上的RGB灯亮绿色。

<p align="center">
<img src="../_static/media/uhand uno-6/6-56.png" alt="6-56" style="width:500px"/>
</p>

2. 当我们将蓝色小球放在ESP32-Cam摄像头前方左右移动时，手掌掌心会跟随小球左右移动。

<p align="center">
	<img src="../_static/media/uhand uno-6/6-57.png" alt="6-57" style="height:400px"/>
    <img src="../_static/media/uhand uno-6/6-58.png" alt="6-58" style="height:400px"/>
</p>

### 3.程序简要分析

本玩法程序名为“**uhand_colors_trace_esp32cam.ino**”，关于程序的实现逻辑可参考下面的流程图：

<p align="center">
<img src="../_static/media/uhand uno-6/6-59.png" alt="6-59" style="width:700px"/>
</p>

- #### 导入库文件

导入本玩法所需的RGB控制库以及舵机控制库、蜂鸣器的音调库以及ESP32Cam库文件。

```c
#include <FastLED.h> //导入LED库
#include <Servo.h> //导入舵机库
#include "hw_esp32cam_ctl.h" //导入ESP32Cam通讯库
#include "tone.h" //音调库
```

- #### 定义引脚及创建对象

1. 定义了蜂鸣器的音调，定义引脚：包括舵机、蜂鸣器以及RGB彩灯的硬件接口。

```c
/* 定义蜂鸣器音调 */
const static uint16_t DOC5[] = { TONE_C5 };
const static uint16_t DOC6[] = { TONE_C6 };

/* 引脚定义 */
const static uint8_t servoPins[6] = { 7, 6, 5, 4, 3, 2 };
const static uint8_t buzzerPin = 11;
const static uint8_t rgbPin = 13;
```

2. 接着创建了RGB灯的控制对象、ESP32Cam的通讯对象以及舵机的控制对象。

```c
//RGB灯控制对象
static CRGB rgbs[1];
//ESP32Cam通讯对象
HW_ESP32Cam hw_cam;
//舵机控制对象
Servo servos[6];
```

3. 然后定义舵机角度的相关变量，其中**extended_func_angles\[6\]** 为期望角度，可以在后续控制舵机匀速转动到指定位置。**servo_angles\[6\]** 为舵机实际角度，是指舵机当前的实际角度。

4. 之后定义的是蜂鸣器的相关变量，其中**tune_num**为蜂鸣器响的次数。**tune_beat**为每一次响的间隔时间，也就是蜂鸣器的频率。最后是一个蜂鸣器的指针，指向一个蜂鸣器的声调变量。

5. 最后声明了舵机的控制函数、蜂鸣器鸣响的函数、蜂鸣器控制任务以及ESP32Cam通信的任务。

```c
 // 舵机角度相关变量
static uint8_t extended_func_angles[6] = { 80, 100, 100, 80, 70, 95 }; /* 二次开发例程使用的角度数值 */
static float servo_angles[6] = { 80, 100, 100, 80, 70, 95 };  /* 舵机实际控制的角度数值 */

// 蜂鸣器相关变量
static uint16_t tune_num = 0;
static uint32_t tune_beat = 10;
static uint16_t *tune;

static void servo_control(void); /* 舵机控制 */
void play_tune(uint16_t *p, uint32_t beat, uint16_t len); /* 蜂鸣器鸣响接口 */
void tune_task(void); /* 蜂鸣器控制任务 */
void espcam_task(void); /* esp32cam通讯任务 */
```

对于期望值与实际值，可以看到loop主函数中调用的**servo_control**函数。

如果想要让舵机逐渐向目标位置靠近，则控制任务函数中需要调用到**servo_angles\[i\] = servo_angles\[i\] \* 0.90 + extended_func_angles\[i\] \* 0.1**这行代码。

这使得舵机每次都会以实际值的90%+期望值的10%来移动，从而实际值逐渐接近期望值，当等于期望值时，手掌就能够停止移动。

```c
//舵机控制任务
void servo_control(void) {
  static uint32_t last_tick = 0;
  if (millis() - last_tick < 40) {
    return;
  }
  last_tick = millis();
  for (int i = 0; i < 6; ++i) {
    servo_angles[i] = servo_angles[i] * 0.85 + extended_func_angles[i] * 0.15;
    servos[i].write(i == 0 || i == 5 ? 180 - servo_angles[i] : servo_angles[i]);
  }
}
```

- #### 初始化设置

1. 在**setup()** 函数中，主要是对相关的硬件设备进行初始化。首先是串口，将其通信的波特率设置为115200以及读取数据超时时间为500ms。

```c
void setup() {
  Serial.begin(115200);
  // 设置串行端口读取数据的超时时间
  Serial.setTimeout(500);
```

2. 绑定舵机IO口，方便通过引脚对其进行控制。

```c
  // 绑定舵机IO口
  for (int i = 0; i < 6; ++i) {
    servos[i].attach(servoPins[i],500,2500);
  }
```

3. 使用**FastLED**库初始化扩展板上的RGB灯，并连接到**rgbPin**引脚。通过**rgbs\[0\] = CRGB(0, 0, 100)**设置颜色为蓝色，使用**FastLED.show**函数显示设置的颜色。

```c
  //RGB灯初始化并控制
  FastLED.addLeds<WS2812, rgbPin, GRB>(rgbs, 1);
  rgbs[0] = CRGB(0, 255, 0);
  FastLED.show();
```

4. 设置蜂鸣器的引脚为输出模式，控制蜂鸣器短鸣一声后停止。

```c
  //蜂鸣器初始化并鸣响一声
  pinMode(buzzerPin, OUTPUT);
  tone(buzzerPin, 1000);
  delay(100);
  noTone(buzzerPin);
```

5. 通过串口输出“Start”字符串，表明传感器已经做好准备，并开始传输数据了。

```c
  delay(500);
  Serial.println("start");
}
```

- #### 循环调用子函数

初始化完成后，进入**loop**主函数，依次循环调用“**espcam_task**”函数，与esp32Cam之间通信，颜色识别的结果，执行转动手掌的操作；调用“**tune_task**”函数，执行蜂鸣器任务；调用“**servo_control**”函数，控制舵机。

```c
void loop() {
  // esp32cam通讯任务
  espcam_task();
  // 蜂鸣器鸣响任务
  tune_task();
  // 舵机控制
  servo_control();
}
```

- #### esp32cam通讯任务

1. 定义“**espcam_task**”函数，首先定义了两个变量，**last_tick**变量结合**millis()** 作延时操作，具体的通过**millis()** 函数获取到当前程序运行的时间，与**last_tick**变量作差，如果差值小于75，则跳出该函数；如果大于或等于75，则意味着已经延时了75ms，接着再将当前的时间赋值给last_tick变量，用作下一次的延时操作。

color_info\[4\]数组用于存储esp32cam返回的数据。其中，下标所对应的数据为：\[0\]-识别到颜色左上角的x坐标，\[1\]-识别到颜色左上角的y坐标，\[2\]-识别到颜色范围的宽度，\[3\]-识别到颜色范围的高度。

```c
// esp32cam通讯任务
void espcam_task(void)
{
  static uint32_t last_tick = 0;
  uint16_t color_info[4];

  // 时间间隔
  if (millis() - last_tick < 75) {
    return;
  }
  last_tick = millis();
```

2. 接着，通过**color_position()** 函数判断是否识别了指定颜色，若识别到再计算颜色块的中心点，根据中心点的位置映射到对应的舵机角度，再控制舵机运动追踪。

```c
  if(hw_cam.color_position(color_info)) //若识别到颜色
  {
    uint16_t num = color_info[0] + color_info[2]/2; //计算颜色块中心
    uint16_t angle = map(num , 0 , 320 , 60 , 120); //映射到对应的舵机角度
    extended_func_angles[5] = angle; //控制舵机运动追踪
  }
}
```

- #### 舵机控制任务

同样，通过**last_tick**变量做延时，延时40ms。使用for循环将每一个舵机的角度值通过舵机接口，传递给每一个舵机，控制舵机转动。

```c
//舵机控制任务
void servo_control(void) {
  static uint32_t last_tick = 0;
  if (millis() - last_tick < 40) {
    return;
  }
  last_tick = millis();
  for (int i = 0; i < 6; ++i) {
    servo_angles[i] = servo_angles[i] * 0.85 + extended_func_angles[i] * 0.15;
    servos[i].write(i == 0 || i == 5 ? 180 - servo_angles[i] : servo_angles[i]);
  }
}
```

- ####  蜂鸣器任务

控制蜂鸣器按照指定的节奏和音调数组播放旋律。

```c
// 蜂鸣器任务
void tune_task(void) {
```

1. 声明变量，**l_tune_beat** 变量，用于存储上一次播放音调的间隔时间（以毫秒为单位）；last_tick变量，用于存储上一次函数执行的时间戳。控制蜂鸣器按照指定的节奏和音调数组播放旋律。

```c
  static uint32_t l_tune_beat = 0;
  static uint32_t last_tick = 0;
```

2. 判断是否需要播放音调，使用 **millis()** 函数获取当前的时间戳，并与 **last_tick** 进行比较。如果当前时间与上一次播放音调的时间间隔小于 **l_tune_beat**，并且 **tune_beat** 的值没有变化（即 **tune_beat** 与 **l_tune_beat** 相等），则函数直接返回，不执行任何操作。这是为了防止在相同的间隔时间内重复播放相同的音调。

```c
  // 若未到定时时间 且 响的次数跟上一次的一样
  if (millis() - last_tick < l_tune_beat && tune_beat == l_tune_beat) {
    return;
  }
```

3. 更新变量，将 **tune_beat** 的值赋给 **l_tune_beat**；更新 **last_tick** 为当前时间戳。

```c
  l_tune_beat = tune_beat;
  last_tick = millis();
```

4. 如果 **tune_num** 大于 0，表示还有剩余的音调需要播放，使用 **tone()** 函数在 **buzzerPin** 引脚上播放当前音调。

```c
  if (tune_num > 0) {
    tune_num -= 1;
    tone(buzzerPin, *tune++);
```

5. 如果 **tune_num** 不大于 0，表示所有的音调都已经播放完毕；使用 **noTone()** 函数停止蜂鸣器发声；重置 **tune_beat** 和 **l_tune_beat** 为 10（可能是默认的播放间隔），准备下一次播放旋律。

```c
  } else {
    noTone(buzzerPin);
    tune_beat = 10;
    l_tune_beat = 10;
  }
}
```

- #### 蜂鸣器发声控制

指定要播放的音调数组、播放音调的间隔以及要播放的音调数量。

```c
// 蜂鸣器鸣响函数
void play_tune(uint16_t *p, uint32_t beat, uint16_t len) {
  tune = p;
  tune_beat = beat;
  tune_num = len;
}
```

tune = p;将变量 tune（是一个指向音调数组的指针）设置为传入的参数 p 的值。这样，tune 就指向了用户提供的音调数组。

tune_beat = beat;将变量 tune_beat（表示播放音调的间隔）设置为传入的参数 beat 的值。这决定了音调的播放节奏。

tune_num = len;将变量 tune_num（表示要播放的音调的数量）设置为传入的参数 len 的值。这确定了播放列表的长度。

### 4.功能延伸

这里以修改ESP32-Cam识别到的颜色为例来进行说明，将原来识别蓝色更改为其他颜色，同时uHand UNO扩展板上的RGB灯亮识别出的颜色，此处以黄色为例。具体修改内容可参考下面步骤：

1. 首先参照本章节下的“6.3图像回传”玩法步骤，将黄色物体放至在摄像头能检测到的位置，再将回传图像保存。
2. 接着打开本文档同路径下的“**thresholding-filter-browser.html**”，在网页中上传刚才保存的图片。

<p align="center">
<img src="../_static/media/uhand uno-6/6-52.png" alt="6-52" style="width:700px"/>
</p>


3. 通过拖动下方滑块，设置LAB阈值范围，反馈图片中显示白色的区域为可识别。此处我们需要设置为识别黄色物体，所以将反馈图片设置为仅显示黄色物体。

<p align="center">
<img src="../_static/media/uhand uno-6/6-53.png" alt="6-53" style="width:700px"/>
</p>


4. 然后将LAB阈值保存，打开本文档同路径下的“**02 程序文件/01 ESP32-Cam颜色识别程序/ESP32Cam_color_clamp/ESP32Cam_color_clamp.ino**”程序，将原先的蓝色LAB数组注释掉，更改为保存的黄色LAB数组,最后参考“[3.2ESP32-Cam程序下载](#_3.2ESP32-Cam程序下载)”将修改好后的程序烧录进ESP32-Cam内。

```c
int8_t color_threshold[COLOR_NUM][6] = {
  {15,80,15,62,15,35},// {15,80,15,62,15,50}, //, red
  // {14, 61, -39, -6, 0, 14},//Green
  //{21,50,-7,8,-35,-11} , //blue
   {57,89,-19,-5,37,63} //YELLOW

  // {65, 78, -10, -5, 38, 50},//yellow
  // {20, 50, 17, 37, -34, -14}//purple

  // {21, 53, 7, 33, -10, 8} //EVA RED
  // {43, 68, -26, -13, 4, 20}, //EVA GREEN
  // {49, 74, -7, 1, -20, -10} //EVA BLUE
  // {43,91,-8,6,-27,-10} //EVA BLUE 2
};
```



5. 修改好LAB数据后，打开本文档同路径下的“**uhand_colors_trace_esp32cam/uhand_colors_trace_esp32cam.ino**”程序，将识别到黄色时的RGB彩灯改为黄色。

```c
      }else if(color == COLOR_2)
      {
        rgbs[0].r = 250;     
        rgbs[0].g = 250;
        rgbs[0].b = 0;
        FastLED.show();
        play_tune(DOC6, 300u, 1u);
        step++;
```

6. 最后参考前面的程序下载方法将程序烧录到uHand UNO中，烧录完成后就能实现识别出黄色物体并亮黄色灯。



## 6.6 人脸识别

本节通过ESP32-Cam识别人脸，识别到人脸后执行招手的动作。

### 1.实现流程图

<p align="center">
<img src="../_static/media/uhand uno-6/6-60.png" alt="6-60" style="width:700px"/>
</p>
### 2.ESP32-Cam人脸识别固件烧录

1. 参照“**1.教程资料\\6.AI视觉玩法课程\\6.3 图像回传-6.1图像回传固件烧录**”中的内容，将本文档同路径下的“**02 程序文件\\01 ESP32-Cam人脸识别固件\\ESP32Cam_face_detect_bin\\face_IIC_slave_vf0.bin**”固件烧录到ESP32-Cam中。

<p align="center">
<img src="../_static/media/uhand uno-6/6-62.png" alt="6-62" style="width:700px"/>
</p>

2. 烧录完成后将Type-C数据线断开，并将机械手掌开机即可。

### 3.实现效果

1. 打开机械手掌电源后，机械手掌云台回到中位，五指张开，同时扩展板上的RGB灯亮绿色。

<p align="center">
<img src="../_static/media/uhand uno-6/6-63.png" alt="6-63" style="width:700px"/>
</p>

2. 当识别到人脸时，手掌做出招手的动作。

<p align="center">
	<img src="../_static/media/uhand uno-6/6-64.png" alt="6-64" style="height:500px"/>
    <img src="../_static/media/uhand uno-6/6-65.png" alt="6-65" style="height:500px"/>
</p>

### 4.程序简要分析

本玩法程序名为“**uhand_face_esp32cam.ino**”，关于程序的实现逻辑可参考下面的流程图：

<p align="center">
<img src="../_static/media/uhand uno-6/6-66.png" alt="6-66" style="width:700px"/>
</p>

- #### 导入库文件

1. 导入玩法所需的RGB控制库、舵机控制库、ESP32Cam的通信库、蜂鸣器的音调库文件。

```c
#include <FastLED.h> //导入LED库
#include <Servo.h> //导入舵机库
#include "hw_esp32cam_ctl.h" //导入ESP32Cam通讯库
#include "tone.h" //导入音调库
```

2. 定义音调常量。

```c
const static uint16_t DOC5[] = { TONE_C5 };
const static uint16_t DOC6[] = { TONE_C6 };
```

- #### 定义引脚及创建对象

3. 首先定义了用于连接硬件的Arduino引脚，主要是六个舵机引脚、一个蜂鸣器引脚和一个RGB灯引脚。

```C
/* 引脚定义 */
const static uint8_t servoPins[6] = { 7, 6, 5, 4, 3, 2 };
const static uint8_t buzzerPin = 11;
const static uint8_t rgbPin = 13;
```

4. 接着定义了用于控制RGB灯、ESP32Cam通讯、舵机的变量。extended_func_angles数组用于存储每个舵机的期望角度，而servo_angles数组用于存储舵机的实际角度，范围是0~180，这里是设置了手掌初始位置为张开；

```C
//RGB灯控制对象
static CRGB rgbs[1];
//ESP32Cam通讯对象
HW_ESP32Cam hw_cam;
//舵机控制对象
Servo servos[6];

// 舵机角度相关变量
static uint8_t extended_func_angles[6] = { 180, 180, 180, 180, 180, 90 }; /* 二次开发例程使用的角度数值 */
static float servo_angles[6] = { 180, 180, 180, 180, 180, 90 };  /* 舵机实际控制的角度数值 */
```

对于期望值与实际值，可以看到loop主函数中调用的**servo_control**函数。

如果想要让舵机逐渐向目标位置靠近，则控制任务函数中需要调用到**servo_angles\[i\] = servo_angles\[i\] \* 0.85 + extended_func_angles\[i\] \* 0.15**这行代码。

这使得舵机每次都会以实际值的85%+期望值的15%来移动，从而实际值逐渐接近期望值，当等于期望值时，手掌就能够停止移动。

```C
//舵机控制任务
void servo_control(void) {
  static uint32_t last_tick = 0;
  if (millis() - last_tick < 40) {
    return;
  }
  last_tick = millis();
  for (int i = 0; i < 6; ++i) {
    servo_angles[i] = servo_angles[i] * 0.85 + extended_func_angles[i] * 0.15;
    servos[i].write(i == 0 || i == 5 ? 180 - servo_angles[i] : servo_angles[i]);
  }
}
```

5. 接着定义了用于控制蜂鸣器的变量，并声明任务函数，用于执行不同的控制任务。**servo_control**函数用于控制舵机；**play_tune**用于控制蜂鸣器鸣响；**tune_task**函数用于执行蜂鸣器任务，**espcam_task**函数用于处理与ESP32-CAM相关的通信。

```C
// 蜂鸣器相关变量
static uint16_t tune_num = 0;
static uint32_t tune_beat = 10;
static uint16_t *tune;

static void servo_control(void); /* 舵机控制 */
void play_tune(uint16_t *p, uint32_t beat, uint16_t len); /* 蜂鸣器控制接口 */
void tune_task(void); /* 蜂鸣器控制任务 */
void espcam_task(void);  /* esp32cam通讯任务 */
```

- #### 初始化设置

1. 在**setup()** 函数中，主要是对相关的硬件设备进行初始化。首先是串口，将其通信的波特率设置为115200以及读取数据超时时间为500ms。

```C
void setup() {
  Serial.begin(115200);
  // 设置串行端口读取数据的超时时间
  Serial.setTimeout(500);
```

2. 绑定舵机IO口，方便通过引脚对其进行控制。

```C
  // 绑定舵机IO口
  for (int i = 0; i < 6; ++i) {
    servos[i].attach(servoPins[i],500,2500);
  }
```

3. 初始化与ESP32-CAM的通信接口并设置ESP32-CAM的补光灯亮度为0（在0到255的范围内，为0时关闭补光灯）。

```C
  hw_cam.begin(); //初始化与ESP32Cam通讯接口
  hw_cam.set_led(0); // 控制ESP32Cam补光灯亮度 [亮度值(0~255)]
```

4. 使用FastLED库初始化扩展板上的RGB灯，并连接到rgbPin引脚。通过rgbs\[0\] = CRGB(0, 255, 0)设置颜色为绿色，使用FastLED.show函数显示设置的颜色。

```C
  //RGB灯初始化并控制
  FastLED.addLeds<WS2812, rgbPin, GRB>(rgbs, 1);
  rgbs[0] = CRGB(0, 255, 0);
  FastLED.show();
```

5. 设置蜂鸣器的引脚为输出模式，控制蜂鸣器短鸣一声后停止。

```C
  //蜂鸣器初始化并鸣响一声
  pinMode(buzzerPin, OUTPUT);
  tone(buzzerPin, 1000);
  delay(100);
  noTone(buzzerPin);
```

6. 通过串口输出“**Start**”字符串，表明传感器已经做好准备，并开始传输数据了。

```C
  delay(500);
  Serial.println("start");
}
```

- #### 循环调用子函数

初始化完成后，进入loop主函数，依次循环调用“**espcam_task**”函数，检测人脸识别，执行招手的动作；调用“**tune_task**”函数，执行蜂鸣器任务；调用“**servo_control**”函数，控制舵机。

```C
void loop() {
  // esp32cam通讯任务
  espcam_task();
  // 蜂鸣器鸣响任务
  tune_task();
  // 舵机控制
  servo_control();
}
```

- #### esp32cam通讯任务

定义“**espcam_task**”函数，检测人脸识别，执行招手的动作。

1. 首先定义了5个变量。last_tick变量，用于记录上一次任务执行的时间点；posi变量定义云台舵机的角度；step变量，跟踪当前任务执行的阶段；delay_count变量设置延时的计量单位；res变量存放摄像头的检测结果。

```C
// esp32cam通讯任务
void espcam_task(void)
{
  static uint32_t last_tick = 0;
  static int posi = 90;
  static uint8_t step = 0;
  static uint8_t delay_count = 0;
  int res = 0;
```

2. last_tick变量结合millis()作延时操作，具体的通过millis()函数获取到当前程序运行的时间，与last_tick变量作差，如果差值小于50，则跳出该函数；如果大于或等于50，则意味着已经延时了50ms，接着再将当前的时间赋值给last_tick变量，用作下一次的延时操作。

```C
  if (millis() - last_tick < 50) {
    return;
  }
  last_tick = millis();
```

3. 将检测结果赋值给res变量。

```C
  res = hw_cam.faceDetect();
```

4. 检测到人脸则执行招手的动作，未检测到则静止。下文为switch代码段的分析：

- case 0：根据hw_cam.colorDetect()检测人脸，若检测到人脸，则让RGB亮红灯，蜂鸣器发声，进入下一个状态。

```C
  switch(step)
  {
    case 0:
      if(res != 0) 
      {
        rgbs[0].r = 250;
        rgbs[0].g = 0;
        rgbs[0].b = 0;
        FastLED.show();
        play_tune(DOC6, 300u, 1u);
        Serial.println("find face");
        step++;
```

若未检测到人脸则关闭RGB灯。

```C
      }else{
        rgbs[0].r = 0;
        rgbs[0].g = 100;
        rgbs[0].b = 100;
        FastLED.show();
      }
      break;
```

- case 1：等待250ms后再进入下一个状态，给摄像头足够的时间完成人脸检测。

```C
    case 1:  //等待
      delay_count++;
      if(delay_count > 5)
      {
        step++;
        delay_count = 0;
      }
      break;
```

- case 2：微微闭合手掌，将ID（1~5）舵机张开角度设置为45°；将delay_count设为0，转移到下一个状态。

```C
    case 2://闭合
      control_hand(0);
      delay_count = 0;
      step++;
      break;
```

调用control_hand();函数，调节舵机ID1~5的转动角度，范围为0~180，为0闭合，180张开。

```C
void control_hand(uint8_t angle)
{
  angle = angle > 180 ? 180 : angle;
  for(int i = 0 ; i < 5 ; i++)
  {
    extended_func_angles[i] = angle;
  }
}
```

- case 3：等待250ms后（等待动作完成）再进入下一个状态。

```C
    case 3: //等待
      delay_count++;
      if(delay_count > 10)
      {
        step++;
      }
      break;
```

- case 4：张开手掌，将ID（1~5）舵机张开角度设置为180°；将delay_count设为0，转移到下一个状态。

```C
    case 4://张开
      control_hand(180);
      delay_count = 0;
      step++;
      break;
```

- case 5：等待500ms（等待动作运行完成），进入下一个状态。

```C
    case 5: //等待
      delay_count++;
      if(delay_count > 15)
      {
        step++;
      }
      break;
```

- case 6~9与上文同理。

```C
    case 6://闭合
      control_hand(0);
      delay_count = 0;
      step++;
      break;
    case 7: //等待
      delay_count++;
      if(delay_count > 15)
      {
        step++;
      }
      break;
    case 8://张开
      control_hand(180);
      delay_count = 0;
      step++;
      break;
    case 9: //等待
      delay_count++;
      if(delay_count > 15)
      {
        step = 0;
      }
      break;
```

- 待动作执行完毕后，将状态值设置为0，重新开始新一轮的检测。


```C
    default:
      step = 0;
      break;
  }
}
```

- #### 舵机控制

如果想要让舵机逐渐向目标位置靠近，则控制任务函数中需要调用到**servo_angles\[i\] = servo_angles\[i\] \* 0.85 + extended_func_angles\[i\] \* 0.15**这行代码。

这使得舵机每次都会以实际值的85%+期望值的15%来移动，从而实际值逐渐接近期望值，当等于期望值时，手掌就能够停止移动。

```C
//舵机控制任务
void servo_control(void) {
  static uint32_t last_tick = 0;
  if (millis() - last_tick < 40) {
    return;
  }
  last_tick = millis();
  for (int i = 0; i < 6; ++i) {
    servo_angles[i] = servo_angles[i] * 0.85 + extended_func_angles[i] * 0.15;
    servos[i].write(i == 0 || i == 5 ? 180 - servo_angles[i] : servo_angles[i]);
  }
}
```

- #### 蜂鸣器控制

控制蜂鸣器按照指定的节奏和音调数组播放旋律。

```C
  static uint32_t l_tune_beat = 0;
  static uint32_t last_tick = 0;
```

1. 声明变量，l_tune_beat变量，用于存储上一次播放音调的间隔时间（以毫秒为单位）；last_tick变量，用于存储上一次函数执行的时间戳。控制蜂鸣器按照指定的节奏和音调数组播放旋律。

```C
  static uint32_t l_tune_beat = 0;
  static uint32_t last_tick = 0;
```

2. 判断是否需要播放音调，使用 millis() 函数获取当前的时间戳，并与 last_tick 进行比较。如果当前时间与上一次播放音调的时间间隔小于 l_tune_beat，并且 tune_beat 的值没有变化（即 tune_beat 与 l_tune_beat 相等），则函数直接返回，不执行任何操作。这是为了防止在相同的间隔时间内重复播放相同的音调。

```C
  // 若未到定时时间 且 响的次数跟上一次的一样
  if (millis() - last_tick < l_tune_beat && tune_beat == l_tune_beat) {
    return;
  }
```

3. 更新变量，将 tune_beat 的值赋给 l_tune_beat；更新 last_tick 为当前时间戳。

```C
  l_tune_beat = tune_beat;
  last_tick = millis();
```

4. 如果 tune_num 大于 0，表示还有剩余的音调需要播放，使用 tone() 函数在 buzzerPin 引脚上播放当前音调。

```C
  if (tune_num > 0) {
    tune_num -= 1;
    tone(buzzerPin, *tune++);
```

5. 如果 tune_num 不大于 0，表示所有的音调都已经播放完毕；使用 noTone() 函数停止蜂鸣器发声；重置 tune_beat 和 l_tune_beat 为 10（可能是默认的播放间隔），准备下一次播放旋律。

```C
  } else {
    noTone(buzzerPin);
    tune_beat = 10;
    l_tune_beat = 10;
  }
}
```

- #### 蜂鸣器发声控制

指定要播放的音调数组、播放音调的间隔以及要播放的音调数量。

```C
// 蜂鸣器鸣响函数
void play_tune(uint16_t *p, uint32_t beat, uint16_t len) {
  tune = p;
  tune_beat = beat;
  tune_num = len;
}
```

tune = p;将变量 tune（是一个指向音调数组的指针）设置为传入的参数 p 的值。这样，tune 就指向了用户提供的音调数组。

tune_beat = beat;将变量 tune_beat（表示播放音调的间隔）设置为传入的参数 beat 的值。这决定了音调的播放节奏。

tune_num = len;将变量 tune_num（表示要播放的音调的数量）设置为传入的参数 len 的值。这确定了播放列表的长度。